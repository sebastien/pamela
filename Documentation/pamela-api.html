<html>
<!-- Document generated by SDoc <http://www.ivy.fr/sdoc> -->
<head>
<title>Python API documentation (SDoc)</title>
<!-- snip-snip-snip-snip-snip-snip -->
<style type="text/css" media="screen">
/* css-main-snip */
html, body {
	background : #fcfcf6;
	color: #000000;
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	padding: 0;
	margin: 0;
}


a, a:active, a:link, a:visited, a:hover {
	color: #404040;
	text-decoration: none;
}

a:active, a:focus {
	background-color: #eae08c;
	color: white;
	border: 0;
	padding: 2px;
}

a:hover {
	color: #8fb216;
}

code {
	color: #8fb216;
}

pre {
	padding-top: 5pt;
	padding-bottom: 5pt;
	background: #f0f0f0;
	color: #8fb216;
}

/* css-main-snip */
/* css-classes-snip */
#descriptions {
	padding: 0;
	margin: 0;
	margin-left: 380px;
}

#options {
	display: none;
	text-align: right;
}

#options label {
	font-weight: bold;
	padding-left: 10px;
}

#modules,
#api {
	display: block;
	width: 200px;
	float: left;
	padding:0;
	padding-left: 5pt;
	padding-right: 10pt;
	background: white;
	border-right: 1px solid #f0f0f0;
	overflow: auto;
	height: 100%;
}

#api {
	margin-right: 10pt;
}

#modules ul {
	margin: 0;
	padding: 0;
}

#modules ul li {
	list-style-type: none;
	padding: 0;
}

#hidden {
	padding: 0;
	margin: 0;
	display: none;
}

#sdoc .description {
	display: none;
	padding: 5pt;
}

#sdoc .representation {
	padding-bottom: 5pt;
}


#sdoc .title {
	padding-top: 10pt;
	font-weight: bold;
	border-bottom: 1px solid #f0f0f0;
	color: #505050;
}

#sdoc .prefix {
	color: #D0C0C0;
	font-style: italic;
	padding-right: 5px;
}

#sdoc .noattributes {
	color: #D0C0C0;
	font-style: italic;
}

#sdoc .name, #sdoc .name a {
	color: #cdb425;
}

#sdoc .term {
	font-weight:bold;
	color: #cdb425;
	background: #F9FFDE;
	padding-left: 2px;
	padding-right: 2px;
}

#sdoc .name {
	font-weight: bold;
	margin-top: 1em;
}

#sdoc .special {
	font-weight: bold;
}

#sdoc .special.__bases__ {
	font-weight: normal;
	color: #cdb425;
}

#sdoc .undocumented, #sdoc .undocumented a {
	color: #b0c0c0;
	font-style: italic;
}
#sdoc .docstring {
	border-top: 1px solid #f0f0f0;
	border-bottom: 1px solid #f0f0f0;
	background: white;
	padding: 5pt;
	color: #808080;
}

#sdoc table caption {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	font-weight: bold;
}

#sdoc table tr td {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	color: #808080;
}

#sdoc .root, #sdoc .container {
	color: #404040;
}

#sdoc .container {
	margin-left: 10pt;
}


/* css-classes-snip */
</style>
<!-- snip-snip-snip-snip-snip-snip -->
<script type="text/javascript" src="http://jqueryjs.googlecode.com/files/jquery-1.2.2.pack.js" > </script>
<script type="text/javascript">
/* <![CDATA[ */
// javascript-snip

var displays    = [];
var selected    = undefined;
var description = undefined;
var hidden      = undefined;
var content     = undefined;

function documentElement( from_id, to_id )
{
	if ( to_id == undefined ) { to_id = from_id ; from_id = undefined; }
	if ( hidden  == undefined ) hidden  = document.getElementById("hidden");
	if ( content == undefined ) content = document.getElementById("api");
	// We get the target element and the associated description element
	var element  = document.getElementById(to_id);
	var felement = document.getElementById(from_id);
	var level    = 0;
	if ( felement != undefined )
	{
		level        = felement.getAttribute("level");
		if ( !level ) { level = 0; }
		else { level = parseInt(level); }
	}
	else
	{
		level = 0;
	}
	// We show the element description
	describeElement(to_id);
	// We show the element
	if (element)
	{
		if ( element == selected ) return;
		// We re-order the content nodes anyway
		element.parentNode.removeChild(element);
		element.setAttribute("level", level + 1);
		content.appendChild(element);
		// Ensure that the node is visible
		element.style.display  = "block";
		// And its description
		// We hide the old ones
		while ( displays.length > 0 && displays.length > level )
		{
			var hiding_id = displays.pop()
			var hiding_el = document.getElementById(hiding_id);
			if ( hiding_el != element )
			{
				hiding_el.parentNode.removeChild(hiding_el);
				hidden.appendChild(hiding_el);
			}
		}
		// And update the state
		displays.push(to_id);
		selected = element;
	}
}

function describeElement( eid )
{
	var delement = document.getElementById("d_" + eid);
	if ( delement != undefined && delement != description )
	{
		delement.style.display = "block";
		if ( description != undefined ) description.style.display = "none";
		description = delement;
	}
	else if ( delement == undefined )
	{
		alert("ERROR: Description not found for id 'd_" + eid + "'");
	}
}

var J = jQuery

function updatePrivateVisibility () {
	/* FIXME: Use proper class instead */
	if ( J(".do-togglePrivate").attr("checked") ) {
		J(".private").parent().parent().fadeIn()
	} else {
		J(".private").parent().parent().fadeOut()
	}
}

function updateProtectedVisibility () {
	if ( J(".do-toggleProtected").attr("checked") ) {
		J(".protected").parent().parent().fadeIn()
	} else {
		J(".protected").parent().parent().fadeOut()
	}
}

jQuery(document).ready(function(){
	J(".do-togglePrivate").click(updatePrivateVisibility)
	J(".do-toggleProtected").click(updateProtectedVisibility)
	updatePrivateVisibility()
	updateProtectedVisibility()
})

// javascript-snip
/* ]]> */
<!-- snip-snip-snip-snip-snip-snip -->
</script>
</head>
<body onLoad="javascript:documentElement('a');">
<!-- body -->
<div id="sdoc">
<div id='modules'>
<!-- modules-snip -->
<div class='container'><div class='name'>$TITLE</div><div class='title'>Modules</div><ul class='group'><li><span class='prefix'>M</span><a href='javascript:documentElement("a");'>engine</a><li><li><span class='prefix'>M</span><a href='javascript:documentElement("a");'>engine</a><li></ul></div>
<div id='options'>
	<label>Show:</label>
	<input type="checkbox" class="do-togglePrivate"> private
	<input type="checkbox" class="do-toggleProtected"> protected
</div>
<!-- modules-snip -->
</div>
<div id='api'><!-- main element will be displayed here --></div>
<div id='descriptions'>
	<!-- descriptions-snip -->
	<div id='d_c' class='description'><h1>tuple</h1><div class='representation'><code>(&lt;class engine.Element at 0x8602dac&gt;,)</code></div><div class='docstring'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_d' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self, name, attributes=None )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_e' class='description'><h1>Method <span class='name'>_attributesAsHTML</span></h1><div class='representation'><code>_attributesAsHTML( self )</code></div><div class='docstring'><pre>Returns the attributes as HTML</pre></div></div><div id='d_f' class='description'><h1>Method <span class='name'>append</span></h1><div class='representation'><code>append( self, n )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_g' class='description'><h1>Method <span class='name'>contentAsLines</span></h1><div class='representation'><code>contentAsLines( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_h' class='description'><h1>Method <span class='name'>setMode</span></h1><div class='representation'><code>setMode( self, mode )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_b' class='description'><h1>Class <span class='name'>Declaration</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_j' class='description'><h1>tuple</h1><div class='representation'><code>()</code></div><div class='docstring'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_k' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self, name, attributes=None, isInline=False, isPI=False )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_l' class='description'><h1>Method <span class='name'>_attributesAsHTML</span></h1><div class='representation'><code>_attributesAsHTML( self )</code></div><div class='docstring'><pre>Returns the attributes as HTML</pre></div></div><div id='d_m' class='description'><h1>Method <span class='name'>append</span></h1><div class='representation'><code>append( self, n )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_n' class='description'><h1>Method <span class='name'>contentAsLines</span></h1><div class='representation'><code>contentAsLines( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_o' class='description'><h1>Method <span class='name'>setMode</span></h1><div class='representation'><code>setMode( self, mode )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_i' class='description'><h1>Class <span class='name'>Element</span></h1><div class='representation'></div><div class='docstring'><pre>Represents an element within the HTML document.</pre></div></div><div id='d_q' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self )</code></div><div class='docstring'><pre>Creates a new formatter.</pre></div></div><div id='d_r' class='description'><h1>Method <span class='name'>_ensureNewLine</span></h1><div class='representation'><code>_ensureNewLine( self )</code></div><div class='docstring'><pre>Ensures that there is a new line.</pre></div></div><div id='d_s' class='description'><h1>Method <span class='name'>_formatContent</span></h1><div class='representation'><code>_formatContent( self, element )</code></div><div class='docstring'><pre>Formats the content of the given element. This uses the formatting
		operations defined in this class.</pre></div></div><div id='d_t' class='description'><h1>Method <span class='name'>_formatElement</span></h1><div class='representation'><code>_formatElement( self, element )</code></div><div class='docstring'><pre>Formats the given element and its content, by using the formatting
		operations defined in this class.</pre></div></div><div id='d_u' class='description'><h1>Method <span class='name'>_inlineCanSpanOneLine</span></h1><div class='representation'><code>_inlineCanSpanOneLine( self, element )</code></div><div class='docstring'><pre>Tells wether the given element (when considered as an inline) can
		span one single line. It can if only it has inlines that can span
		one line and text without EOLs as content.</pre></div></div><div id='d_v' class='description'><h1>Method <span class='name'>_isNewLine</span></h1><div class='representation'><code>_isNewLine( self )</code></div><div class='docstring'><pre>Tells wether the current line is a new line.</pre></div></div><div id='d_w' class='description'><h1>Method <span class='name'>_iterateOnWords</span></h1><div class='representation'><code>_iterateOnWords( self, text )</code></div><div class='docstring'><pre>Splits the given text into words (separated by ' ', '	' or '
') and
		returns an iterator on these words.<br />		This function is used by 'wrapText'.</pre></div></div><div id='d_x' class='description'><h1>Method <span class='name'>endIndent</span></h1><div class='representation'><code>endIndent( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_y' class='description'><h1>Method <span class='name'>endWriting</span></h1><div class='representation'><code>endWriting( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_z' class='description'><h1>Method <span class='name'>ensureNewLine</span></h1><div class='representation'><code>ensureNewLine( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_A' class='description'><h1>Method <span class='name'>findFlag</span></h1><div class='representation'><code>findFlag( self, flag )</code></div><div class='docstring'><pre>Finds the level at which the given flag is defined. Returns -1 if it
		is not found.</pre></div></div><div id='d_B' class='description'><h1>Method <span class='name'>format</span></h1><div class='representation'><code>format( self, document, indent=0 )</code></div><div class='docstring'><pre>Formats the given document, starting at the given indentation (0 by
		default).</pre></div></div><div id='d_C' class='description'><h1>Method <span class='name'>formatText</span></h1><div class='representation'><code>formatText( self, text )</code></div><div class='docstring'><pre>Returns the given text properly formatted according to
		this formatted configuration.</pre></div></div><div id='d_D' class='description'><h1>Method <span class='name'>getDefaults</span></h1><div class='representation'><code>getDefaults( self, elementName )</code></div><div class='docstring'><pre>Gets the formatting defaults for the given element name.</pre></div></div><div id='d_E' class='description'><h1>Method <span class='name'>getFlags</span></h1><div class='representation'><code>getFlags( self )</code></div><div class='docstring'><pre>Returns the list of defined flags, by order of definition (last flags
		are more recent.</pre></div></div><div id='d_F' class='description'><h1>Method <span class='name'>hasFlag</span></h1><div class='representation'><code>hasFlag( self, flag )</code></div><div class='docstring'><pre>Tells if the given flag is currently defined.</pre></div></div><div id='d_G' class='description'><h1>Method <span class='name'>indentAsSpaces</span></h1><div class='representation'><code>indentAsSpaces( self, indent=None, increment=0 )</code></div><div class='docstring'><pre>Converts the 'indent' value to a string filled with spaces or tabs
		depending on the formatter parameters.</pre></div></div><div id='d_H' class='description'><h1>Method <span class='name'>indentString</span></h1><div class='representation'><code>indentString( self, text, indent=None, start=True, end=False )</code></div><div class='docstring'><pre>Indents the given 'text' with the given 'value' (which will be
		converted to either spaces or tabs, depending on the formatter
		parameters.<br />		If 'start' is True, then the start line will be indented as well,
		otherwise it won't. When 'end' is True, a newline is inserted at
		the end of the resulting text, otherwise not.</pre></div></div><div id='d_I' class='description'><h1>Method <span class='name'>newLine</span></h1><div class='representation'><code>newLine( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_J' class='description'><h1>Method <span class='name'>normalizeText</span></h1><div class='representation'><code>normalizeText( self, text )</code></div><div class='docstring'><pre>Replaces the tabs and eols by spaces, ignoring the value of tabs.</pre></div></div><div id='d_K' class='description'><h1>Method <span class='name'>popFlags</span></h1><div class='representation'><code>popFlags( self )</code></div><div class='docstring'><pre>Pops the given flags from the flags queue.</pre></div></div><div id='d_L' class='description'><h1>Method <span class='name'>pushFlags</span></h1><div class='representation'><code>pushFlags( self, *flags )</code></div><div class='docstring'><pre>Pushes the given flags (as varargs) on the flags queue.</pre></div></div><div id='d_M' class='description'><h1>Method <span class='name'>reformatText</span></h1><div class='representation'><code>reformatText( self, text )</code></div><div class='docstring'><pre>Reformats a text so that it fits a particular text width.</pre></div></div><div id='d_N' class='description'><h1>Method <span class='name'>setDefaults</span></h1><div class='representation'><code>setDefaults( self, element, formatOptions=() )</code></div><div class='docstring'><pre>Sets the formatting defaults for the given element name.</pre></div></div><div id='d_O' class='description'><h1>Method <span class='name'>setFlag</span></h1><div class='representation'><code>setFlag( self, flag )</code></div><div class='docstring'><pre>Sets the given flag.</pre></div></div><div id='d_P' class='description'><h1>Method <span class='name'>setFlags</span></h1><div class='representation'><code>setFlags( self, *flags )</code></div><div class='docstring'><pre>Set the given flags, given as varargs.</pre></div></div><div id='d_Q' class='description'><h1>Method <span class='name'>startIndent</span></h1><div class='representation'><code>startIndent( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_R' class='description'><h1>Method <span class='name'>startWriting</span></h1><div class='representation'><code>startWriting( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_S' class='description'><h1>Method <span class='name'>stripText</span></h1><div class='representation'><code>stripText( self, text )</code></div><div class='docstring'><pre>Strips leading and trailing spaces or eols from this text</pre></div></div><div id='d_T' class='description'><h1>Method <span class='name'>wrapText</span></h1><div class='representation'><code>wrapText( self, text, offset=0, textWidth=80, indent=None )</code></div><div class='docstring'><pre>Wraps the given text at the given 'textWidth', starting at the given
		'offset' with the given optional 'ident'.</pre></div></div><div id='d_U' class='description'><h1>Method <span class='name'>writeTag</span></h1><div class='representation'><code>writeTag( self, tagText )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_V' class='description'><h1>Method <span class='name'>writeText</span></h1><div class='representation'><code>writeText( self, text )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_p' class='description'><h1>Class <span class='name'>Formatter</span></h1><div class='representation'></div><div class='docstring'><pre>Formats the elements of the Pamela object model. A formatter really acts
	as a state machine, and keeps track of the various formatting hints bound to
	the Pamela XML/HTML elements to render the document in the most appropriate
	way.<br />	If you instanciate a formatter, you'll have access to the following
	attributes, which can influence the generated text:<br />	 - 'indent=0'
	 - 'indentValue="  "'
	 - 'textWidth=80'
	 - 'defaults=HTML_DEFAULT'<br />	</pre></div></div><div id='d_X' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Y' class='description'><h1>Method <span class='name'>_getLineIndent</span></h1><div class='representation'><code>_getLineIndent( self, line )</code></div><div class='docstring'><pre>Returns the line indentation as a number. It takes into account the
		fact that tabs may be requried or not, and also takes into account the
		'tabsWith' property.</pre></div></div><div id='d_Z' class='description'><h1>Method <span class='name'>_gotoParentElement</span></h1><div class='representation'><code>_gotoParentElement( self, currentIndent )</code></div><div class='docstring'><pre>Finds the parent element that has an identation lower than the given
		'currentIndent'.</pre></div></div><div id='d_ab' class='description'><h1>Method <span class='name'>_isInEmbed</span></h1><div class='representation'><code>_isInEmbed( self )</code></div><div class='docstring'><pre>Tells if the current element is an embed element (like
		CSS,PHP,etc)</pre></div></div><div id='d_bb' class='description'><h1>Method <span class='name'>_parseContentLine</span></h1><div class='representation'><code>_parseContentLine( self, line )</code></div><div class='docstring'><pre>Parses a line that is data/text that is part of an element
		content.</pre></div></div><div id='d_cb' class='description'><h1>Method <span class='name'>_parseLine</span></h1><div class='representation'><code>_parseLine( self, line )</code></div><div class='docstring'><pre>Parses the given line of text.
		This is an internal method that you should not really use directly.</pre></div></div><div id='d_db' class='description'><h1>Method <span class='name'>_parsePamelaAttributes</span></h1><div class='representation'><code>_parsePamelaAttributes( self, attributes )</code></div><div class='docstring'><pre>Parses a string representing Pamela attributes and returns a list of
		couples '[name, value]' representing the attributes.</pre></div></div><div id='d_eb' class='description'><h1>Method <span class='name'>_parsePamelaElement</span></h1><div class='representation'><code>_parsePamelaElement( self, element )</code></div><div class='docstring'><pre>Parses the declaration of a Pamela element, which is like the
		following examples:<br />		&gt;	html
		&gt;	title:
		&gt;	body#main.body(onclick=load)|c:<br />		basically, it is what lies between '&lt;' and the ':' (or '
'), which can
		be summmed up as:<br />		&gt;	(#ID | NAME #ID?) .CLASS* ATTRIBUTES? |HINTS? :?<br />		where attributes is a command-separated sequence of this, surrounded by
		parens:<br />		&gt;	NAME=(VALUE|'VALUE'|"VALUE")<br />		This function returns a triple (name, attributes, hints)
		representing the parsed element. Attributes are stored as an ordered
		list of couples '(name, value'), hints are given as a list of strings.</pre></div></div><div id='d_fb' class='description'><h1>Method <span class='name'>_popStack</span></h1><div class='representation'><code>_popStack( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_gb' class='description'><h1>Method <span class='name'>_pushStack</span></h1><div class='representation'><code>_pushStack( self, indent, type, mode=None )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_hb' class='description'><h1>Method <span class='name'>indent</span></h1><div class='representation'><code>indent( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_ib' class='description'><h1>Method <span class='name'>parseFile</span></h1><div class='representation'><code>parseFile( self, path )</code></div><div class='docstring'><pre>Parses the file with the given  path, and return the corresponding
		HTML document.</pre></div></div><div id='d_jb' class='description'><h1>Method <span class='name'>parseString</span></h1><div class='representation'><code>parseString( self, text, path=None )</code></div><div class='docstring'><pre>Parses the given string and returns an HTML document.</pre></div></div><div id='d_kb' class='description'><h1>Method <span class='name'>path</span></h1><div class='representation'><code>path( self )</code></div><div class='docstring'><pre>Returns the current path of the file being parsed, if any</pre></div></div><div id='d_W' class='description'><h1>Class <span class='name'>Parser</span></h1><div class='representation'></div><div class='docstring'><pre>Implements a parser that will turn a Pamela document into an HTML
	document, returned as a string.<br />	The main methods that you should use are<br />	- 'parseFile' to parse file identified by the given path
	- 'parseString' to parse a string given as parameter<br />	You can configure the parser by using the following methods:<br />	- 'acceptTabsOnly', to tell that the parser will only accept tabs.
	- 'acceptSpacesOnly', to tell that the parser will only accept spaces.
	- 'acceptTabsAndSpaces', to tell that the parser will accept both tabs and
	   spaces.
	- 'tabsWidth', to specify the width of a tab in spaces, which is only used
	   when the parser accepts both tabs and spaces.
	</pre></div></div><div id='d_mb' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self, content )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_nb' class='description'><h1>Method <span class='name'>contentAsLines</span></h1><div class='representation'><code>contentAsLines( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_lb' class='description'><h1>Class <span class='name'>Text</span></h1><div class='representation'></div><div class='docstring'><pre>Reprensents a text fragment within the HTML document.</pre></div></div><div id='d_pb' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_qb' class='description'><h1>Method <span class='name'>_node</span></h1><div class='representation'><code>_node( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_rb' class='description'><h1>Method <span class='name'>_popStack</span></h1><div class='representation'><code>_popStack( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_sb' class='description'><h1>Method <span class='name'>_pushStack</span></h1><div class='representation'><code>_pushStack( self, node )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_tb' class='description'><h1>Method <span class='name'>mode</span></h1><div class='representation'><code>mode( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_ub' class='description'><h1>Method <span class='name'>onComment</span></h1><div class='representation'><code>onComment( self, line )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_vb' class='description'><h1>Method <span class='name'>onDeclarationEnd</span></h1><div class='representation'><code>onDeclarationEnd( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_wb' class='description'><h1>Method <span class='name'>onDeclarationStart</span></h1><div class='representation'><code>onDeclarationStart( self, name, attributes=None )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_xb' class='description'><h1>Method <span class='name'>onDocumentEnd</span></h1><div class='representation'><code>onDocumentEnd( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_yb' class='description'><h1>Method <span class='name'>onDocumentStart</span></h1><div class='representation'><code>onDocumentStart( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_zb' class='description'><h1>Method <span class='name'>onElementEnd</span></h1><div class='representation'><code>onElementEnd( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Ab' class='description'><h1>Method <span class='name'>onElementStart</span></h1><div class='representation'><code>onElementStart( self, name, attributes=None, isInline=False )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Bb' class='description'><h1>Method <span class='name'>onTextAdd</span></h1><div class='representation'><code>onTextAdd( self, text )</code></div><div class='docstring'><pre>Adds the given text fragment to the current element.</pre></div></div><div id='d_Cb' class='description'><h1>Method <span class='name'>popMode</span></h1><div class='representation'><code>popMode( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Db' class='description'><h1>Method <span class='name'>pushMode</span></h1><div class='representation'><code>pushMode( self, name )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_ob' class='description'><h1>Class <span class='name'>Writer</span></h1><div class='representation'></div><div class='docstring'><pre>The Writer class implements a simple SAX-like interface to create the
	resulting HTML/XML document. This is not API-compatible with SAX because
	Pamela as slightly differnt information than what SAX offers, which requires
	specific methods.</pre></div></div><div id='d_Eb' class='description'><h1>Function <span class='name'>parse</span></h1><div class='representation'><code>parse( text, path=None )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Fb' class='description'><h1>Function <span class='name'>run</span></h1><div class='representation'><code>run( arguments, input=None )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Gb' class='description'><h1>str</h1><div class='representation'><code>'c'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Hb' class='description'><h1>str</h1><div class='representation'><code>'i'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Ib' class='description'><h1>str</h1><div class='representation'><code>'ib'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Jb' class='description'><h1>str</h1><div class='representation'><code>'n'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Kb' class='description'><h1>tuple</h1><div class='representation'><code>('i', 'ib', 'sl', 'p', 'n', 's', 'c')</code></div><div class='docstring'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_Lb' class='description'><h1>str</h1><div class='representation'><code>'p'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Mb' class='description'><h1>str</h1><div class='representation'><code>'sl'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Nb' class='description'><h1>str</h1><div class='representation'><code>'s'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Ob' class='description'><h1>str</h1><div class='representation'><code>'w'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Pb' class='description'><h1>dict</h1><div class='representation'><code>{'pre': ['p'], 'code': ['n', 's', 'c'], 'p': ['n', 's', 'c', 'w'], 'title': ['sl', 'n', 's'], 'h2': ['sl', 'n', 's'], 'h3': ['sl', 'n', 's'], 'h1': ['sl', 'n', 's'], 'h4': ['sl', 'n', 's'], 'script': ['i'], 'link': ['i'], 'div': ['ib']}</code></div><div class='docstring'><pre>dict() -&gt; new empty dictionary.
dict(mapping) -&gt; new dictionary initialized from a mapping object's
    (key, value) pairs.
dict(seq) -&gt; new dictionary initialized as if via:
    d = {}
    for k, v in seq:
        d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)</pre></div></div><div id='d_Qb' class='description'><h1>dict</h1><div class='representation'><code>{'canvas': {'NOT_EMPTY': ' '}, 'span': {'NOT_EMPTY': ' '}, 'textarea': {'NOT_EMPTY': ' '}, 'script': {'NOT_EMPTY': ' '}, 'iframe': {'NOT_EMPTY': ' '}, 'div': {'NOT_EMPTY': '&nbsp;'}}</code></div><div class='docstring'><pre>dict() -&gt; new empty dictionary.
dict(mapping) -&gt; new dictionary initialized from a mapping object's
    (key, value) pairs.
dict(seq) -&gt; new dictionary initialized as if via:
    d = {}
    for k, v in seq:
        d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)</pre></div></div><div id='d_Rb' class='description'><h1>str</h1><div class='representation'><code>'0.4.0'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Sb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_Tb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_Ub' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_Vb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_Wb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_Xb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_Yb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_Zb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_ac' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_bc' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_cc' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_dc' class='description'><h1>str</h1><div class='representation'><code>'(\\??([\\w\\d_-]+::)?[\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_ec' class='description'><h1>str</h1><div class='representation'><code>'\\((\\??([\\w\\d_-]+::)?[\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?(,(\\??([\\w\\d_-]+::)?[\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?)*\\)'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_fc' class='description'><h1>str</h1><div class='representation'><code>'@\\w+'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_gc' class='description'><h1>str</h1><div class='representation'><code>'&lt;(\\??([\\w\\d_-]+::)?[\\w\\d_-]+((\\#\\??([\\w\\d_-]+::)?[\\w\\d_-]+|\\.\\??([\\w\\d_-]+::)?[\\w\\d_-]+)+)?|(\\#\\??([\\w\\d_-]+::)?[\\w\\d_-]+|\\.\\??([\\w\\d_-]+::)?[\\w\\d_-]+)+)(\\((\\??([\\w\\d_-]+::)?[\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?(,(\\??([\\w\\d_-]+::)?[\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?)*\\))?(@\\w+)?\\:?'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_hc' class='description'><h1>str</h1><div class='representation'><code>'(\\#\\??([\\w\\d_-]+::)?[\\w\\d_-]+|\\.\\??([\\w\\d_-]+::)?[\\w\\d_-]+)+'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_ic' class='description'><h1>str</h1><div class='representation'><code>'\\??([\\w\\d_-]+::)?[\\w\\d_-]+'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_jc' class='description'><h1>str</h1><div class='representation'><code>'DC'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_kc' class='description'><h1>str</h1><div class='representation'><code>'EL'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_lc' class='description'><h1>str</h1><div class='representation'><code>'EM'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_a' class='description'><h1>Module <span class='name'>engine</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div>
	<!-- descriptions-snip -->
</div>
<div id='hidden'>
	<!-- hidden-snip -->
	<div id='d_bc' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_M' class='description'><h1>Method <span class='name'>reformatText</span></h1><div class='representation'><code>reformatText( self, text )</code></div><div class='docstring'><pre>Reformats a text so that it fits a particular text width.</pre></div></div><div id='d_Wb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_eb' class='description'><h1>Method <span class='name'>_parsePamelaElement</span></h1><div class='representation'><code>_parsePamelaElement( self, element )</code></div><div class='docstring'><pre>Parses the declaration of a Pamela element, which is like the
		following examples:<br />		&gt;	html
		&gt;	title:
		&gt;	body#main.body(onclick=load)|c:<br />		basically, it is what lies between '&lt;' and the ':' (or '
'), which can
		be summmed up as:<br />		&gt;	(#ID | NAME #ID?) .CLASS* ATTRIBUTES? |HINTS? :?<br />		where attributes is a command-separated sequence of this, surrounded by
		parens:<br />		&gt;	NAME=(VALUE|'VALUE'|"VALUE")<br />		This function returns a triple (name, attributes, hints)
		representing the parsed element. Attributes are stored as an ordered
		list of couples '(name, value'), hints are given as a list of strings.</pre></div></div><div id='d_ec' class='description'><h1>str</h1><div class='representation'><code>'\\((\\??([\\w\\d_-]+::)?[\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?(,(\\??([\\w\\d_-]+::)?[\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?)*\\)'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Lb' class='description'><h1>str</h1><div class='representation'><code>'p'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_ub' class='description'><h1>Method <span class='name'>onComment</span></h1><div class='representation'><code>onComment( self, line )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='lb' class='container'><div class='name'><a href='javascript:describeElement("lb");'>Text</a></div><div class='title'>Bases</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("lb","j");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='title'>Methods</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("lb","mb");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("lb","nb");'>contentAsLines</a></div></div></div><div id='d_Db' class='description'><h1>Method <span class='name'>pushMode</span></h1><div class='representation'><code>pushMode( self, name )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_mb' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self, content )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Z' class='description'><h1>Method <span class='name'>_gotoParentElement</span></h1><div class='representation'><code>_gotoParentElement( self, currentIndent )</code></div><div class='docstring'><pre>Finds the parent element that has an identation lower than the given
		'currentIndent'.</pre></div></div><div id='d_Tb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_X' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Y' class='description'><h1>Method <span class='name'>_getLineIndent</span></h1><div class='representation'><code>_getLineIndent( self, line )</code></div><div class='docstring'><pre>Returns the line indentation as a number. It takes into account the
		fact that tabs may be requried or not, and also takes into account the
		'tabsWith' property.</pre></div></div><div id='d_R' class='description'><h1>Method <span class='name'>startWriting</span></h1><div class='representation'><code>startWriting( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_S' class='description'><h1>Method <span class='name'>stripText</span></h1><div class='representation'><code>stripText( self, text )</code></div><div class='docstring'><pre>Strips leading and trailing spaces or eols from this text</pre></div></div><div id='d_P' class='description'><h1>Method <span class='name'>setFlags</span></h1><div class='representation'><code>setFlags( self, *flags )</code></div><div class='docstring'><pre>Set the given flags, given as varargs.</pre></div></div><div id='d_Q' class='description'><h1>Method <span class='name'>startIndent</span></h1><div class='representation'><code>startIndent( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_V' class='description'><h1>Method <span class='name'>writeText</span></h1><div class='representation'><code>writeText( self, text )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_W' class='description'><h1>Class <span class='name'>Parser</span></h1><div class='representation'></div><div class='docstring'><pre>Implements a parser that will turn a Pamela document into an HTML
	document, returned as a string.<br />	The main methods that you should use are<br />	- 'parseFile' to parse file identified by the given path
	- 'parseString' to parse a string given as parameter<br />	You can configure the parser by using the following methods:<br />	- 'acceptTabsOnly', to tell that the parser will only accept tabs.
	- 'acceptSpacesOnly', to tell that the parser will only accept spaces.
	- 'acceptTabsAndSpaces', to tell that the parser will accept both tabs and
	   spaces.
	- 'tabsWidth', to specify the width of a tab in spaces, which is only used
	   when the parser accepts both tabs and spaces.
	</pre></div></div><div id='d_T' class='description'><h1>Method <span class='name'>wrapText</span></h1><div class='representation'><code>wrapText( self, text, offset=0, textWidth=80, indent=None )</code></div><div class='docstring'><pre>Wraps the given text at the given 'textWidth', starting at the given
		'offset' with the given optional 'ident'.</pre></div></div><div id='d_U' class='description'><h1>Method <span class='name'>writeTag</span></h1><div class='representation'><code>writeTag( self, tagText )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_J' class='description'><h1>Method <span class='name'>normalizeText</span></h1><div class='representation'><code>normalizeText( self, text )</code></div><div class='docstring'><pre>Replaces the tabs and eols by spaces, ignoring the value of tabs.</pre></div></div><div id='d_K' class='description'><h1>Method <span class='name'>popFlags</span></h1><div class='representation'><code>popFlags( self )</code></div><div class='docstring'><pre>Pops the given flags from the flags queue.</pre></div></div><div id='d_H' class='description'><h1>Method <span class='name'>indentString</span></h1><div class='representation'><code>indentString( self, text, indent=None, start=True, end=False )</code></div><div class='docstring'><pre>Indents the given 'text' with the given 'value' (which will be
		converted to either spaces or tabs, depending on the formatter
		parameters.<br />		If 'start' is True, then the start line will be indented as well,
		otherwise it won't. When 'end' is True, a newline is inserted at
		the end of the resulting text, otherwise not.</pre></div></div><div id='d_I' class='description'><h1>Method <span class='name'>newLine</span></h1><div class='representation'><code>newLine( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_N' class='description'><h1>Method <span class='name'>setDefaults</span></h1><div class='representation'><code>setDefaults( self, element, formatOptions=() )</code></div><div class='docstring'><pre>Sets the formatting defaults for the given element name.</pre></div></div><div id='d_O' class='description'><h1>Method <span class='name'>setFlag</span></h1><div class='representation'><code>setFlag( self, flag )</code></div><div class='docstring'><pre>Sets the given flag.</pre></div></div><div id='d_L' class='description'><h1>Method <span class='name'>pushFlags</span></h1><div class='representation'><code>pushFlags( self, *flags )</code></div><div class='docstring'><pre>Pushes the given flags (as varargs) on the flags queue.</pre></div></div><div id='d_bb' class='description'><h1>Method <span class='name'>_parseContentLine</span></h1><div class='representation'><code>_parseContentLine( self, line )</code></div><div class='docstring'><pre>Parses a line that is data/text that is part of an element
		content.</pre></div></div><div id='d_B' class='description'><h1>Method <span class='name'>format</span></h1><div class='representation'><code>format( self, document, indent=0 )</code></div><div class='docstring'><pre>Formats the given document, starting at the given indentation (0 by
		default).</pre></div></div><div id='d_C' class='description'><h1>Method <span class='name'>formatText</span></h1><div class='representation'><code>formatText( self, text )</code></div><div class='docstring'><pre>Returns the given text properly formatted according to
		this formatted configuration.</pre></div></div><div id='d_A' class='description'><h1>Method <span class='name'>findFlag</span></h1><div class='representation'><code>findFlag( self, flag )</code></div><div class='docstring'><pre>Finds the level at which the given flag is defined. Returns -1 if it
		is not found.</pre></div></div><div id='d_F' class='description'><h1>Method <span class='name'>hasFlag</span></h1><div class='representation'><code>hasFlag( self, flag )</code></div><div class='docstring'><pre>Tells if the given flag is currently defined.</pre></div></div><div id='d_G' class='description'><h1>Method <span class='name'>indentAsSpaces</span></h1><div class='representation'><code>indentAsSpaces( self, indent=None, increment=0 )</code></div><div class='docstring'><pre>Converts the 'indent' value to a string filled with spaces or tabs
		depending on the formatter parameters.</pre></div></div><div id='d_D' class='description'><h1>Method <span class='name'>getDefaults</span></h1><div class='representation'><code>getDefaults( self, elementName )</code></div><div class='docstring'><pre>Gets the formatting defaults for the given element name.</pre></div></div><div id='d_E' class='description'><h1>Method <span class='name'>getFlags</span></h1><div class='representation'><code>getFlags( self )</code></div><div class='docstring'><pre>Returns the list of defined flags, by order of definition (last flags
		are more recent.</pre></div></div><div id='d_z' class='description'><h1>Method <span class='name'>ensureNewLine</span></h1><div class='representation'><code>ensureNewLine( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_x' class='description'><h1>Method <span class='name'>endIndent</span></h1><div class='representation'><code>endIndent( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_y' class='description'><h1>Method <span class='name'>endWriting</span></h1><div class='representation'><code>endWriting( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_rb' class='description'><h1>Method <span class='name'>_popStack</span></h1><div class='representation'><code>_popStack( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_r' class='description'><h1>Method <span class='name'>_ensureNewLine</span></h1><div class='representation'><code>_ensureNewLine( self )</code></div><div class='docstring'><pre>Ensures that there is a new line.</pre></div></div><div id='d_s' class='description'><h1>Method <span class='name'>_formatContent</span></h1><div class='representation'><code>_formatContent( self, element )</code></div><div class='docstring'><pre>Formats the content of the given element. This uses the formatting
		operations defined in this class.</pre></div></div><div id='d_p' class='description'><h1>Class <span class='name'>Formatter</span></h1><div class='representation'></div><div class='docstring'><pre>Formats the elements of the Pamela object model. A formatter really acts
	as a state machine, and keeps track of the various formatting hints bound to
	the Pamela XML/HTML elements to render the document in the most appropriate
	way.<br />	If you instanciate a formatter, you'll have access to the following
	attributes, which can influence the generated text:<br />	 - 'indent=0'
	 - 'indentValue="  "'
	 - 'textWidth=80'
	 - 'defaults=HTML_DEFAULT'<br />	</pre></div></div><div id='d_q' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self )</code></div><div class='docstring'><pre>Creates a new formatter.</pre></div></div><div id='d_v' class='description'><h1>Method <span class='name'>_isNewLine</span></h1><div class='representation'><code>_isNewLine( self )</code></div><div class='docstring'><pre>Tells wether the current line is a new line.</pre></div></div><div id='d_w' class='description'><h1>Method <span class='name'>_iterateOnWords</span></h1><div class='representation'><code>_iterateOnWords( self, text )</code></div><div class='docstring'><pre>Splits the given text into words (separated by ' ', '	' or '
') and
		returns an iterator on these words.<br />		This function is used by 'wrapText'.</pre></div></div><div id='d_t' class='description'><h1>Method <span class='name'>_formatElement</span></h1><div class='representation'><code>_formatElement( self, element )</code></div><div class='docstring'><pre>Formats the given element and its content, by using the formatting
		operations defined in this class.</pre></div></div><div id='d_u' class='description'><h1>Method <span class='name'>_inlineCanSpanOneLine</span></h1><div class='representation'><code>_inlineCanSpanOneLine( self, element )</code></div><div class='docstring'><pre>Tells wether the given element (when considered as an inline) can
		span one single line. It can if only it has inlines that can span
		one line and text without EOLs as content.</pre></div></div><div id='d_j' class='description'><h1>tuple</h1><div class='representation'><code>()</code></div><div class='docstring'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='p' class='container'><div class='name'><a href='javascript:describeElement("p");'>Formatter</a></div><div class='title'>Bases</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("p","j");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='title'>Methods</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("p","q");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","r");'><span class='protected'>_ensureNewLine</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","s");'><span class='protected'>_formatContent</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","t");'><span class='protected'>_formatElement</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","u");'><span class='protected'>_inlineCanSpanOneLine</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","v");'><span class='protected'>_isNewLine</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","w");'><span class='protected'>_iterateOnWords</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","x");'>endIndent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","y");'>endWriting</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","z");'>ensureNewLine</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","A");'>findFlag</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","B");'>format</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","C");'>formatText</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","D");'>getDefaults</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","E");'>getFlags</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","F");'>hasFlag</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","G");'>indentAsSpaces</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","H");'>indentString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","I");'>newLine</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","J");'>normalizeText</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","K");'>popFlags</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","L");'>pushFlags</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","M");'>reformatText</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","N");'>setDefaults</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","O");'>setFlag</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","P");'>setFlags</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","Q");'>startIndent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","R");'>startWriting</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","S");'>stripText</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","T");'>wrapText</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","U");'>writeTag</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("p","V");'>writeText</a></div></div></div><div id='d_h' class='description'><h1>Method <span class='name'>setMode</span></h1><div class='representation'><code>setMode( self, mode )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_i' class='description'><h1>Class <span class='name'>Element</span></h1><div class='representation'></div><div class='docstring'><pre>Represents an element within the HTML document.</pre></div></div><div id='d_n' class='description'><h1>Method <span class='name'>contentAsLines</span></h1><div class='representation'><code>contentAsLines( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_o' class='description'><h1>Method <span class='name'>setMode</span></h1><div class='representation'><code>setMode( self, mode )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_l' class='description'><h1>Method <span class='name'>_attributesAsHTML</span></h1><div class='representation'><code>_attributesAsHTML( self )</code></div><div class='docstring'><pre>Returns the attributes as HTML</pre></div></div><div id='d_m' class='description'><h1>Method <span class='name'>append</span></h1><div class='representation'><code>append( self, n )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_b' class='description'><h1>Class <span class='name'>Declaration</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_c' class='description'><h1>tuple</h1><div class='representation'><code>(&lt;class engine.Element at 0x8602dac&gt;,)</code></div><div class='docstring'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_a' class='description'><h1>Module <span class='name'>engine</span></h1><div class='representation'></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_f' class='description'><h1>Method <span class='name'>append</span></h1><div class='representation'><code>append( self, n )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_g' class='description'><h1>Method <span class='name'>contentAsLines</span></h1><div class='representation'><code>contentAsLines( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_d' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self, name, attributes=None )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_jb' class='description'><h1>Method <span class='name'>parseString</span></h1><div class='representation'><code>parseString( self, text, path=None )</code></div><div class='docstring'><pre>Parses the given string and returns an HTML document.</pre></div></div><div id='d_ob' class='description'><h1>Class <span class='name'>Writer</span></h1><div class='representation'></div><div class='docstring'><pre>The Writer class implements a simple SAX-like interface to create the
	resulting HTML/XML document. This is not API-compatible with SAX because
	Pamela as slightly differnt information than what SAX offers, which requires
	specific methods.</pre></div></div><div id='d_Ib' class='description'><h1>str</h1><div class='representation'><code>'ib'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_gb' class='description'><h1>Method <span class='name'>_pushStack</span></h1><div class='representation'><code>_pushStack( self, indent, type, mode=None )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_gc' class='description'><h1>str</h1><div class='representation'><code>'&lt;(\\??([\\w\\d_-]+::)?[\\w\\d_-]+((\\#\\??([\\w\\d_-]+::)?[\\w\\d_-]+|\\.\\??([\\w\\d_-]+::)?[\\w\\d_-]+)+)?|(\\#\\??([\\w\\d_-]+::)?[\\w\\d_-]+|\\.\\??([\\w\\d_-]+::)?[\\w\\d_-]+)+)(\\((\\??([\\w\\d_-]+::)?[\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?(,(\\??([\\w\\d_-]+::)?[\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?)*\\))?(@\\w+)?\\:?'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Nb' class='description'><h1>str</h1><div class='representation'><code>'s'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Yb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_k' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self, name, attributes=None, isInline=False, isPI=False )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_wb' class='description'><h1>Method <span class='name'>onDeclarationStart</span></h1><div class='representation'><code>onDeclarationStart( self, name, attributes=None )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Eb' class='description'><h1>Function <span class='name'>parse</span></h1><div class='representation'><code>parse( text, path=None )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Fb' class='description'><h1>Function <span class='name'>run</span></h1><div class='representation'><code>run( arguments, input=None )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Qb' class='description'><h1>dict</h1><div class='representation'><code>{'canvas': {'NOT_EMPTY': ' '}, 'span': {'NOT_EMPTY': ' '}, 'textarea': {'NOT_EMPTY': ' '}, 'script': {'NOT_EMPTY': ' '}, 'iframe': {'NOT_EMPTY': ' '}, 'div': {'NOT_EMPTY': '&nbsp;'}}</code></div><div class='docstring'><pre>dict() -&gt; new empty dictionary.
dict(mapping) -&gt; new dictionary initialized from a mapping object's
    (key, value) pairs.
dict(seq) -&gt; new dictionary initialized as if via:
    d = {}
    for k, v in seq:
        d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)</pre></div></div><div id='d_Vb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_dc' class='description'><h1>str</h1><div class='representation'><code>'(\\??([\\w\\d_-]+::)?[\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_db' class='description'><h1>Method <span class='name'>_parsePamelaAttributes</span></h1><div class='representation'><code>_parsePamelaAttributes( self, attributes )</code></div><div class='docstring'><pre>Parses a string representing Pamela attributes and returns a list of
		couples '[name, value]' representing the attributes.</pre></div></div><div id='W' class='container'><div class='name'><a href='javascript:describeElement("W");'>Parser</a></div><div class='title'>Bases</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("W","j");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='title'>Methods</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("W","X");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","Y");'><span class='protected'>_getLineIndent</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","Z");'><span class='protected'>_gotoParentElement</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","ab");'><span class='protected'>_isInEmbed</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","bb");'><span class='protected'>_parseContentLine</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","cb");'><span class='protected'>_parseLine</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","db");'><span class='protected'>_parsePamelaAttributes</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","eb");'><span class='protected'>_parsePamelaElement</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","fb");'><span class='protected'>_popStack</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","gb");'><span class='protected'>_pushStack</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","hb");'>indent</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","ib");'>parseFile</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","jb");'>parseString</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("W","kb");'>path</a></div></div></div><div id='d_tb' class='description'><h1>Method <span class='name'>mode</span></h1><div class='representation'><code>mode( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Ob' class='description'><h1>str</h1><div class='representation'><code>'w'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='ob' class='container'><div class='name'><a href='javascript:describeElement("ob");'>Writer</a></div><div class='title'>Bases</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("ob","j");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='title'>Methods</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("ob","pb");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","qb");'><span class='protected'>_node</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","rb");'><span class='protected'>_popStack</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","sb");'><span class='protected'>_pushStack</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","tb");'>mode</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","ub");'>onComment</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","vb");'>onDeclarationEnd</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","wb");'>onDeclarationStart</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","xb");'>onDocumentEnd</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","yb");'>onDocumentStart</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","zb");'>onElementEnd</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","Ab");'>onElementStart</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","Bb");'>onTextAdd</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","Cb");'>popMode</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("ob","Db");'>pushMode</a></div></div></div><div id='d_jc' class='description'><h1>str</h1><div class='representation'><code>'DC'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_lc' class='description'><h1>str</h1><div class='representation'><code>'EM'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_lb' class='description'><h1>Class <span class='name'>Text</span></h1><div class='representation'></div><div class='docstring'><pre>Reprensents a text fragment within the HTML document.</pre></div></div><div id='d_e' class='description'><h1>Method <span class='name'>_attributesAsHTML</span></h1><div class='representation'><code>_attributesAsHTML( self )</code></div><div class='docstring'><pre>Returns the attributes as HTML</pre></div></div><div id='d_Gb' class='description'><h1>str</h1><div class='representation'><code>'c'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_xb' class='description'><h1>Method <span class='name'>onDocumentEnd</span></h1><div class='representation'><code>onDocumentEnd( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_ab' class='description'><h1>Method <span class='name'>_isInEmbed</span></h1><div class='representation'><code>_isInEmbed( self )</code></div><div class='docstring'><pre>Tells if the current element is an embed element (like
		CSS,PHP,etc)</pre></div></div><div id='d_ac' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_Kb' class='description'><h1>tuple</h1><div class='representation'><code>('i', 'ib', 'sl', 'p', 'n', 's', 'c')</code></div><div class='docstring'><pre>tuple() -&gt; an empty tuple
tuple(sequence) -&gt; tuple initialized from sequence's items<br />If the argument is a tuple, the return value is the same object.</pre></div></div><div id='d_pb' class='description'><h1>Method <span class='name'>__init__</span></h1><div class='representation'><code>__init__( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_ib' class='description'><h1>Method <span class='name'>parseFile</span></h1><div class='representation'><code>parseFile( self, path )</code></div><div class='docstring'><pre>Parses the file with the given  path, and return the corresponding
		HTML document.</pre></div></div><div id='d_ic' class='description'><h1>str</h1><div class='representation'><code>'\\??([\\w\\d_-]+::)?[\\w\\d_-]+'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Sb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_nb' class='description'><h1>Method <span class='name'>contentAsLines</span></h1><div class='representation'><code>contentAsLines( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_yb' class='description'><h1>Method <span class='name'>onDocumentStart</span></h1><div class='representation'><code>onDocumentStart( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Hb' class='description'><h1>str</h1><div class='representation'><code>'i'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_fc' class='description'><h1>str</h1><div class='representation'><code>'@\\w+'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_fb' class='description'><h1>Method <span class='name'>_popStack</span></h1><div class='representation'><code>_popStack( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_qb' class='description'><h1>Method <span class='name'>_node</span></h1><div class='representation'><code>_node( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='b' class='container'><div class='name'><a href='javascript:describeElement("b");'>Declaration</a></div><div class='title'>Bases</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("b","c");'><span class='special __bases__'>Element</span></a></div></div><div class='title'>Methods</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("b","d");'><span class='special __init__'>constructor</span></a></div></div><div class='title'>Inhertied Methods</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("b","e");'><span class='protected'>_attributesAsHTML</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("b","f");'>append</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("b","g");'>contentAsLines</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("b","h");'>setMode</a></div></div></div><div id='d_Xb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_vb' class='description'><h1>Method <span class='name'>onDeclarationEnd</span></h1><div class='representation'><code>onDeclarationEnd( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Ab' class='description'><h1>Method <span class='name'>onElementStart</span></h1><div class='representation'><code>onElementStart( self, name, attributes=None, isInline=False )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='i' class='container'><div class='name'><a href='javascript:describeElement("i");'>Element</a></div><div class='title'>Bases</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("i","j");'><span class='special __bases__'><i>Base class</i></span></a></div></div><div class='title'>Methods</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&equiv;</span><a href='javascript:documentElement("i","k");'><span class='special __init__'>constructor</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("i","l");'><span class='protected'>_attributesAsHTML</span></a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("i","m");'>append</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("i","n");'>contentAsLines</a></div><div class='slot documented'><span
					class='prefix'>&fnof;</span><a href='javascript:documentElement("i","o");'>setMode</a></div></div></div><div id='d_Pb' class='description'><h1>dict</h1><div class='representation'><code>{'pre': ['p'], 'code': ['n', 's', 'c'], 'p': ['n', 's', 'c', 'w'], 'title': ['sl', 'n', 's'], 'h2': ['sl', 'n', 's'], 'h3': ['sl', 'n', 's'], 'h1': ['sl', 'n', 's'], 'h4': ['sl', 'n', 's'], 'script': ['i'], 'link': ['i'], 'div': ['ib']}</code></div><div class='docstring'><pre>dict() -&gt; new empty dictionary.
dict(mapping) -&gt; new dictionary initialized from a mapping object's
    (key, value) pairs.
dict(seq) -&gt; new dictionary initialized as if via:
    d = {}
    for k, v in seq:
        d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)</pre></div></div><div id='d_Ub' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_cb' class='description'><h1>Method <span class='name'>_parseLine</span></h1><div class='representation'><code>_parseLine( self, line )</code></div><div class='docstring'><pre>Parses the given line of text.
		This is an internal method that you should not really use directly.</pre></div></div><div id='d_cc' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_zb' class='description'><h1>Method <span class='name'>onElementEnd</span></h1><div class='representation'><code>onElementEnd( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Mb' class='description'><h1>str</h1><div class='representation'><code>'sl'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_kb' class='description'><h1>Method <span class='name'>path</span></h1><div class='representation'><code>path( self )</code></div><div class='docstring'><pre>Returns the current path of the file being parsed, if any</pre></div></div><div id='d_kc' class='description'><h1>str</h1><div class='representation'><code>'EL'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_Bb' class='description'><h1>Method <span class='name'>onTextAdd</span></h1><div class='representation'><code>onTextAdd( self, text )</code></div><div class='docstring'><pre>Adds the given text fragment to the current element.</pre></div></div><div id='d_Rb' class='description'><h1>str</h1><div class='representation'><code>'0.4.0'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_sb' class='description'><h1>Method <span class='name'>_pushStack</span></h1><div class='representation'><code>_pushStack( self, node )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Jb' class='description'><h1>str</h1><div class='representation'><code>'n'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='a' class='root'><div class='name'><a href='javascript:describeElement("a");'>engine</a></div><div class='title'>Classes</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","b");'>Declaration</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","i");'>Element</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","p");'>Formatter</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","W");'>Parser</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","lb");'>Text</a></div><div class='slot documented'><span
					class='prefix'>&Tau;</span><a href='javascript:documentElement("a","ob");'>Writer</a></div></div><div class='title'>Functions</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:documentElement("a","Eb");'>parse</a></div><div class='slot documented'><span
					class='prefix'>&lambda;</span><a href='javascript:documentElement("a","Fb");'>run</a></div></div><div class='title'>Values</div class='title'><div class='group'><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Gb");'>FORMAT_COMPACT</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Hb");'>FORMAT_INLINE</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Ib");'>FORMAT_INLINE_BLOCK</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Jb");'>FORMAT_NORMALIZE</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Kb");'>FORMAT_OPTIONS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Lb");'>FORMAT_PRESERVE</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Mb");'>FORMAT_SINGLE_LINE</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Nb");'>FORMAT_STRIP</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Ob");'>FORMAT_WRAP</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Pb");'>HTML_DEFAULTS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Qb");'>HTML_EXCEPTIONS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Rb");'>PAMELA_VERSION</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Sb");'>RE_ATTRIBUTE</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Tb");'>RE_COMMENT</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Ub");'>RE_DECLARATION</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Vb");'>RE_ELEMENT</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Wb");'>RE_EMPTY</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Xb");'>RE_INCLUDE</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Yb");'>RE_INLINE</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","Zb");'>RE_LEADING_SPC</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","ac");'>RE_LEADING_TAB</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","bc");'>RE_SPACE</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","cc");'>RE_SPACES</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","dc");'>SYMBOL_ATTR</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","ec");'>SYMBOL_ATTRS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","fc");'>SYMBOL_CONTENT</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","gc");'>SYMBOL_ELEMENT</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","hc");'>SYMBOL_ID_CLS</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","ic");'>SYMBOL_NAME</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","jc");'>T_DECLARATION</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","kc");'>T_ELEMENT</a></div><div class='slot documented'><span
					class='prefix'>&bull;</span><a href='javascript:documentElement("a","lc");'>T_EMBED</a></div></div></div><div id='d_Cb' class='description'><h1>Method <span class='name'>popMode</span></h1><div class='representation'><code>popMode( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div><div id='d_Zb' class='description'><h1>SRE_Pattern</h1><div class='representation'></div><div class='docstring'><pre>Compiled regular expression objects</pre></div></div><div id='d_hc' class='description'><h1>str</h1><div class='representation'><code>'(\\#\\??([\\w\\d_-]+::)?[\\w\\d_-]+|\\.\\??([\\w\\d_-]+::)?[\\w\\d_-]+)+'</code></div><div class='docstring'><pre>str(object) -&gt; string<br />Return a nice string representation of the object.
If the argument is a string, the return value is the same object.</pre></div></div><div id='d_hb' class='description'><h1>Method <span class='name'>indent</span></h1><div class='representation'><code>indent( self )</code></div><div class='docstring'><span class='undocumented'>Undocumented</span></div></div>
	<!-- hidden-snip -->
	<!-- hidden nodes will be moved here -->
</div>
</div>
<!-- body -->
</body>
</html>
