<html>
<!-- Document generated by SDoc <http://www.ivy.fr/sdoc> -->
<head>
<title>Python API documentation (SDoc)</title>

<style type="text/css" media="screen">
/* css-main-snip */
html, body {
	background : #fcfcf6;
	color: #000000;
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	padding: 0;
	margin: 0;
}


a, a:active, a:link, a:visited, a:hover {
	color: #404040;
	text-decoration: none;
}

a:active, a:focus {
	background-color: #eae08c;
	color: white;
	border: 0;
	padding: 2px;
}

a:hover {
	color: #8fb216;
}

code {
	color: #8fb216;
}

pre {
	padding-top: 5pt;
	padding-bottom: 5pt;
	background: #f0f0f0;
	color: #8fb216;
}

/* css-main-snip */
/* css-classes-snip */
#descriptions {
	padding: 0;
	margin: 0;
	margin-left: 380px;
}

#modules {
	padding: 0;
	padding: 1pt;
	padding-left: 5pt;
	font-size: 7pt;
	color: #A0A0A0;
	background: #404040;
	border-bottom: 2px solid #f0f0f0;
}

#modules a {
	color: white;
}

#api {
	display: block;
	width: 360px;
	float: left;
	padding:0;
	padding-left: 5pt;
	padding-right: 10pt;
	background: white;
	border-right: 1px solid #f0f0f0;
	overflow: auto;
	height: 100%;

}

#hidden {
	padding: 0;
	margin: 0;
	display: none;
}

#sdoc .de {
	display: none;
	padding: 5pt;
}

#sdoc .re {
	padding-bottom: 5pt;
}


#sdoc .t {
	padding-top: 10pt;
	font-weight: bold;
	border-bottom: 1px solid #f0f0f0;
	color: #505050;
}

#sdoc .prefix {
	color: #D0C0C0;
	font-style: italic;
	padding-right: 5px;
}

#sdoc .noattributes {
	color: #D0C0C0;
	font-style: italic;
}

#sdoc .n, #sdoc .n a {
	color: #cdb425;
}

#sdoc .n {
	font-weight: bold;
	margin-top: 1em;
}

#sdoc .special {
	font-weight: bold;
}

#sdoc .special.__bases__ {
	font-weight: normal;
	color: #cdb425;
}

#sdoc .u, #sdoc .u a {
	color: #b0c0c0;
	font-style: italic;
}
#sdoc .ds {
	border-top: 1px solid #f0f0f0;
	border-bottom: 1px solid #f0f0f0;
	background: white;
	padding: 5pt;
	color: #808080;
}

#sdoc table caption {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	font-weight: bold;
}

#sdoc table tr td {
	font: 8pt/14pt "Lucida Grande", "Lucida", Helvetica, sans-serif;
	color: #808080;
}

#sdoc .ro, #sdoc .cr {
	padding-left: 10pt;
	padding-top: 8pt;
	color: #404040;
	width: 150px;
	border-left: 1px solid #f0f0f0;
	float: left;
}

#sdoc .cr {
	margin-left: 10pt;
	display: none;
}


/* css-classes-snip */
</style>

<script type="text/javascript">
// javascript-snip

var displays    = [];
var selected    = undefined;
var description = undefined;
var hidden      = undefined;
var content     = undefined;

function dO( from_id, to_id )
{
	if ( to_id == undefined ) { to_id = from_id ; from_id = undefined; }
	if ( hidden  == undefined ) hidden  = document.getElementById("hidden");
	if ( content == undefined ) content = document.getElementById("api");
	// We get the target element and the associated description element
	var element  = document.getElementById(to_id);
	var felement = document.getElementById(from_id);
	var level    = 0;
	if ( felement != undefined )
	{
		level        = felement.getAttribute("level");
		if ( !level ) { level = 0; }
		else { level = parseInt(level); }
	}
	else
	{
		level = 0;
	}
	// We show the element description
	dS(to_id);
	// We show the element
	if (element)
	{
		if ( element == selected ) return;
		// We re-order the content nodes anyway
		element.parentNode.removeChild(element);
		element.setAttribute("level", level + 1);
		content.appendChild(element);
		// Ensure that the node is visible
		element.style.display  = "block";
		// And its description
		// We hide the old ones
		while ( displays.length > 0 && displays.length > level )
		{
			var hiding_id = displays.pop()
			var hiding_el = document.getElementById(hiding_id);
			if ( hiding_el != element )
			{
				hiding_el.parentNode.removeChild(hiding_el);
				hidden.appendChild(hiding_el);
			}
		}
		// And update the state
		displays.push(to_id);
		selected = element;
	}
}

function dS( eid )
{
	var delement = document.getElementById("d_" + eid);
	if ( delement != undefined && delement != description )
	{
		delement.style.display = "block";
		if ( description != undefined ) description.style.display = "none";
		description = delement;
	}
	else if ( delement == undefined )
	{
		alert("ERROR: Description not found for id 'd_" + eid + "'");
	}
}
// javascript-snip

</script>
</head>
<body onLoad="javascript:dO('a');">
<!-- body -->
<div id="sdoc">
<div id='modules'>
<!-- modules-snip -->
API : <a href='javascript:dO("a");'>engine</a> &bull; <a href='javascript:dO("Rb");'>web</a>
<!-- modules-snip -->
</div>
<div id='api'><!-- main element will be displayed here --></div>
<div id='descriptions'>
	<!-- descriptions-snip -->
	<div id='d_c' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class engine.Element at 0x10b4ed0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_d' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name, attributes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_e' class='de'><h1>Method <span class='n'>_attributesAsHTML</span></h1><div class='re'><code>_attributesAsHTML( self )</code></div><div class='ds'><p>Returns the attributes as HTML</p></div></div><div id='d_f' class='de'><h1>Method <span class='n'>append</span></h1><div class='re'><code>append( self, n )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_b' class='de'><h1>Class <span class='n'>Declaration</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_h' class='de'><h1>tuple</h1><div class='re'><code>()</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_i' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name, attributes=None, isInline=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_j' class='de'><h1>Method <span class='n'>_attributesAsHTML</span></h1><div class='re'><code>_attributesAsHTML( self )</code></div><div class='ds'><p>Returns the attributes as HTML</p></div></div><div id='d_k' class='de'><h1>Method <span class='n'>append</span></h1><div class='re'><code>append( self, n )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_g' class='de'><h1>Class <span class='n'>Element</span></h1><div class='re'></div><div class='ds'><p>Represents an element within the HTML document.</p></div></div><div id='d_m' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><p>Creates a new formatter.</p></div></div><div id='d_n' class='de'><h1>Method <span class='n'>_ensureNewLine</span></h1><div class='re'><code>_ensureNewLine( self )</code></div><div class='ds'><p>Ensures that there is a new line.</p></div></div><div id='d_o' class='de'><h1>Method <span class='n'>_formatContent</span></h1><div class='re'><code>_formatContent( self, element )</code></div><div class='ds'><p>Formats the content of the given element. This uses the formatting operations defined in this class.</p></div></div><div id='d_p' class='de'><h1>Method <span class='n'>_formatElement</span></h1><div class='re'><code>_formatElement( self, element )</code></div><div class='ds'><p>Formats the given element and its content, by using the formatting operations defined in this class.</p></div></div><div id='d_q' class='de'><h1>Method <span class='n'>_inlineCanSpanOneLine</span></h1><div class='re'><code>_inlineCanSpanOneLine( self, element )</code></div><div class='ds'><p>Tells wether the given element (when considered as an inline) can span one single line. It can if only it has inlines that can span one line and text without EOLs as content.</p></div></div><div id='d_r' class='de'><h1>Method <span class='n'>_isNewLine</span></h1><div class='re'><code>_isNewLine( self )</code></div><div class='ds'><p>Tells wether the current line is a new line.</p></div></div><div id='d_s' class='de'><h1>Method <span class='n'>_iterateOnWords</span></h1><div class='re'><code>_iterateOnWords( self, text )</code></div><div class='ds'><p>Splits the given text into words (separated by <code> </code>, <code>	</code> or <code>
</code>) and returns an iterator on these words.</p><p>This function is used by <code>wrapText</code>.</p></div></div><div id='d_t' class='de'><h1>Method <span class='n'>endIndent</span></h1><div class='re'><code>endIndent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_u' class='de'><h1>Method <span class='n'>endWriting</span></h1><div class='re'><code>endWriting( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_v' class='de'><h1>Method <span class='n'>ensureNewLine</span></h1><div class='re'><code>ensureNewLine( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_w' class='de'><h1>Method <span class='n'>findFlag</span></h1><div class='re'><code>findFlag( self, flag )</code></div><div class='ds'><p>Finds the level at which the given flag is defined. Returns -1 if it is not found.</p></div></div><div id='d_x' class='de'><h1>Method <span class='n'>format</span></h1><div class='re'><code>format( self, document, indent=0 )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_y' class='de'><h1>Method <span class='n'>formatText</span></h1><div class='re'><code>formatText( self, text )</code></div><div class='ds'><p>Returns the given text properly formatted according to this formatted configuration.</p></div></div><div id='d_z' class='de'><h1>Method <span class='n'>getDefaults</span></h1><div class='re'><code>getDefaults( self, elementName )</code></div><div class='ds'><p>Gets the formatting defaults for the given element name.</p></div></div><div id='d_A' class='de'><h1>Method <span class='n'>getFlags</span></h1><div class='re'><code>getFlags( self )</code></div><div class='ds'><p>Returns the list of defined flags, by order of definition (last flags are more recent.</p></div></div><div id='d_B' class='de'><h1>Method <span class='n'>hasFlag</span></h1><div class='re'><code>hasFlag( self, flag )</code></div><div class='ds'><p>Tells if the given flag is currently defined.</p></div></div><div id='d_C' class='de'><h1>Method <span class='n'>indentAsSpaces</span></h1><div class='re'><code>indentAsSpaces( self, indent=None, increment=0 )</code></div><div class='ds'><p>Converts the <code>indent</code> value to a string filled with spaces or tabs depending on the formatter parameters.</p></div></div><div id='d_D' class='de'><h1>Method <span class='n'>indentString</span></h1><div class='re'><code>indentString( self, text, indent=None, start=True, end=False )</code></div><div class='ds'><p>Indents the given <code>text</code> with the given <code>value</code> (which will be converted to either spaces or tabs, depending on the formatter parameters.</p><p>If <code>start</code> is True, then the start line will be indented as well, otherwise it won't. When 'end' is True, a newline is inserted at the end of the resulting text, otherwise not.</p></div></div><div id='d_E' class='de'><h1>Method <span class='n'>newLine</span></h1><div class='re'><code>newLine( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_F' class='de'><h1>Method <span class='n'>normalizeText</span></h1><div class='re'><code>normalizeText( self, text )</code></div><div class='ds'><p>Replaces the tabs and eols by spaces, ignoring the value of tabs.</p></div></div><div id='d_G' class='de'><h1>Method <span class='n'>popFlags</span></h1><div class='re'><code>popFlags( self )</code></div><div class='ds'><p>Pops the given flags from the flags queue.</p></div></div><div id='d_H' class='de'><h1>Method <span class='n'>pushFlags</span></h1><div class='re'><code>pushFlags( self, *flags )</code></div><div class='ds'><p>Pushes the given flags (as varargs) on the flags queue.</p></div></div><div id='d_I' class='de'><h1>Method <span class='n'>reformatText</span></h1><div class='re'><code>reformatText( self, text )</code></div><div class='ds'><p>Reformats a text so that it fits a particular text width.</p></div></div><div id='d_J' class='de'><h1>Method <span class='n'>setDefaults</span></h1><div class='re'><code>setDefaults( self, element, formatOptions=() )</code></div><div class='ds'><p>Sets the formatting defaults for the given element name.</p></div></div><div id='d_K' class='de'><h1>Method <span class='n'>setFlag</span></h1><div class='re'><code>setFlag( self, flag )</code></div><div class='ds'><p>Sets the given flag.</p></div></div><div id='d_L' class='de'><h1>Method <span class='n'>setFlags</span></h1><div class='re'><code>setFlags( self, *flags )</code></div><div class='ds'><p>Set the given flags, given as varargs.</p></div></div><div id='d_M' class='de'><h1>Method <span class='n'>startIndent</span></h1><div class='re'><code>startIndent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_N' class='de'><h1>Method <span class='n'>startWriting</span></h1><div class='re'><code>startWriting( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_O' class='de'><h1>Method <span class='n'>stripText</span></h1><div class='re'><code>stripText( self, text )</code></div><div class='ds'><p>Strips leading and trailing spaces or eols from this text</p></div></div><div id='d_P' class='de'><h1>Method <span class='n'>wrapText</span></h1><div class='re'><code>wrapText( self, text, offset=0, textWidth=80, indent=None )</code></div><div class='ds'><p>Wraps the given text at the given <code>textWidth</code>, starting at the given <code>offset</code> with the given optional <code>ident</code>.</p></div></div><div id='d_Q' class='de'><h1>Method <span class='n'>writeTag</span></h1><div class='re'><code>writeTag( self, tagText )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_R' class='de'><h1>Method <span class='n'>writeText</span></h1><div class='re'><code>writeText( self, text )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_l' class='de'><h1>Class <span class='n'>Formatter</span></h1><div class='re'></div><div class='ds'><p>Formats the elements of the Pamela object model. A formatter really acts as a state machine, and keeps track of the various formatting hints bound to the Pamela XML/HTML elements to render the document in the most appropriate way.</p><p>If you instanciate a formatter, you'll have access to the following attributes, which can influence the generated text:</p><ul><li><code>indent=0</code> </li><li><code>indentValue="  "</code> </li><li><code>textWidth=80</code> </li><li><code>defaults=HTML_DEFAULT</code></li></ul></div></div><div id='d_T' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_U' class='de'><h1>Method <span class='n'>_getLineIndent</span></h1><div class='re'><code>_getLineIndent( self, line )</code></div><div class='ds'><p>Returns the line indentation as a number. It takes into account the fact that tabs may be requried or not, and also takes into account the <code>tabsWith</code> property.</p></div></div><div id='d_V' class='de'><h1>Method <span class='n'>_gotoParentElement</span></h1><div class='re'><code>_gotoParentElement( self, currentIndent )</code></div><div class='ds'><p>Finds the parent element that has an identation lower than the given <code>currentIndent</code>.</p></div></div><div id='d_W' class='de'><h1>Method <span class='n'>_parseContentLine</span></h1><div class='re'><code>_parseContentLine( self, line )</code></div><div class='ds'><p>Parses a line that is data/text that is part of an element content.</p></div></div><div id='d_X' class='de'><h1>Method <span class='n'>_parseLine</span></h1><div class='re'><code>_parseLine( self, line )</code></div><div class='ds'><p>Parses the given line of text. This is an internal method that you should not really use directly.</p></div></div><div id='d_Y' class='de'><h1>Method <span class='n'>_parsePamelaAttributes</span></h1><div class='re'><code>_parsePamelaAttributes( self, attributes )</code></div><div class='ds'><p>Parses a string representing Pamela attributes and returns a list of couples <code>[name, value]</code> representing the attributes.</p></div></div><div id='d_Z' class='de'><h1>Method <span class='n'>_parsePamelaElement</span></h1><div class='re'><code>_parsePamelaElement( self, element )</code></div><div class='ds'><p>Parses the declaration of a Pamela element, which is like the following examples:</p><pre>html
title:
body#main.body(onclick=load)|c:</pre><p>basically, it is what lies between <code>&lt;</code> and the <code>:</code> (or <code>
</code>), which can be summmed up as:</p><pre>(#ID | NAME #ID?) .CLASS* ATTRIBUTES? |HINTS? :?</pre><p>where attributes is a command-separated sequence of this, surrounded by parens:</p><pre>NAME=(VALUE|'VALUE'|"VALUE")</pre><p>This function returns a triple (name, attributes, hints) representing the parsed element. Attributes are stored as an ordered list of couples <code>(name, value</code>), hints are given as a list of strings.</p></div></div><div id='d_ab' class='de'><h1>Method <span class='n'>parseFile</span></h1><div class='re'><code>parseFile( self, path )</code></div><div class='ds'><p>Parses the file with the given path, and return the corresponding HTML document.</p></div></div><div id='d_bb' class='de'><h1>Method <span class='n'>parseText</span></h1><div class='re'><code>parseText( self, text )</code></div><div class='ds'><p>Parses the given string and returns an HTML document.</p></div></div><div id='d_S' class='de'><h1>Class <span class='n'>Parser</span></h1><div class='re'></div><div class='ds'><p>Implements a parser that will turn a Pamela document into an HTML document, returned as a string.</p><p>The main methods that you should use are</p><ul><li><code>parseFile</code> to parse file identified by the given path </li><li><code>parseString</code> to parse a string given as parameter</li></ul><p>You can configure the parser by using the following methods:</p><ul><li><code>acceptTabsOnly</code>, to tell that the parser will only accept tabs. </li><li><code>acceptSpacesOnly</code>, to tell that the parser will only accept spaces. </li><li><code>acceptTabsAndSpaces</code>, to tell that the parser will accept both tabs and spaces. </li><li><code>tabsWidth</code>, to specify the width of a tab in spaces, which is only used when the parser accepts both tabs and spaces. </li></ul></div></div><div id='d_db' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cb' class='de'><h1>Class <span class='n'>Text</span></h1><div class='re'></div><div class='ds'><p>Reprensents a text fragment within the HTML document.</p></div></div><div id='d_fb' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_gb' class='de'><h1>Method <span class='n'>_node</span></h1><div class='re'><code>_node( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_hb' class='de'><h1>Method <span class='n'>onComment</span></h1><div class='re'><code>onComment( self, line )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ib' class='de'><h1>Method <span class='n'>onDeclarationEnd</span></h1><div class='re'><code>onDeclarationEnd( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jb' class='de'><h1>Method <span class='n'>onDeclarationStart</span></h1><div class='re'><code>onDeclarationStart( self, name, attributes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_kb' class='de'><h1>Method <span class='n'>onDocumentEnd</span></h1><div class='re'><code>onDocumentEnd( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_lb' class='de'><h1>Method <span class='n'>onDocumentStart</span></h1><div class='re'><code>onDocumentStart( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_mb' class='de'><h1>Method <span class='n'>onElementEnd</span></h1><div class='re'><code>onElementEnd( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_nb' class='de'><h1>Method <span class='n'>onElementStart</span></h1><div class='re'><code>onElementStart( self, name, attributes=None, isInline=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ob' class='de'><h1>Method <span class='n'>onTextAdd</span></h1><div class='re'><code>onTextAdd( self, text )</code></div><div class='ds'><p>Adds the given text fragment to the current element.</p></div></div><div id='d_eb' class='de'><h1>Class <span class='n'>Writer</span></h1><div class='re'></div><div class='ds'><p>The Writer class implements a simple SAX-like interface to create the resulting HTML/XML document. This is not API-compatible with SAX because Pamela as slightly differnt information than what SAX offers, which requires specific methods.</p></div></div><div id='d_pb' class='de'><h1>Function <span class='n'>run</span></h1><div class='re'><code>run( arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qb' class='de'><h1>str</h1><div class='re'><code>'c'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_rb' class='de'><h1>str</h1><div class='re'><code>'i'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_sb' class='de'><h1>str</h1><div class='re'><code>'ib'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_tb' class='de'><h1>str</h1><div class='re'><code>'n'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_ub' class='de'><h1>tuple</h1><div class='re'><code>('i', 'ib', 'sl', 'p', 'n', 's', 'c')</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_vb' class='de'><h1>str</h1><div class='re'><code>'p'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_wb' class='de'><h1>str</h1><div class='re'><code>'sl'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_xb' class='de'><h1>str</h1><div class='re'><code>'s'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_yb' class='de'><h1>str</h1><div class='re'><code>'w'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_zb' class='de'><h1>dict</h1><div class='re'><code>{'pre': ['p'], 'code': ['n', 's', 'c'], 'p': ['n', 's', 'c', 'w'], 'title': ['sl', 'n', 's'], 'h2': ['sl', 'n', 's'], 'h3': ['sl', 'n', 's'], 'h1': ['sl', 'n', 's'], 'h4': ['sl', 'n', 's'], 'script': ['i'], 'link': ['i'], 'div': ['ib']}</code></div><div class='ds'><p>dict() -&gt; new empty dictionary. dict(mapping) -&gt; new dictionary initialized from a mapping object's (key, value) pairs. dict(seq) -&gt; new dictionary initialized as if via: d = {} for k, v in seq: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)</p></div></div><div id='d_Ab' class='de'><h1>dict</h1><div class='re'><code>{'div': {'NOT_EMPTY': '&znjs;'}, 'script': {'NOT_EMPTY': ' '}}</code></div><div class='ds'><p>dict() -&gt; new empty dictionary. dict(mapping) -&gt; new dictionary initialized from a mapping object's (key, value) pairs. dict(seq) -&gt; new dictionary initialized as if via: d = {} for k, v in seq: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)</p></div></div><div id='d_Bb' class='de'><h1>str</h1><div class='re'><code>'0.3.4'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Cb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Db' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Eb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Fb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Gb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Hb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Ib' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Jb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Kb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Lb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Mb' class='de'><h1>str</h1><div class='re'><code>'([\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Nb' class='de'><h1>str</h1><div class='re'><code>'\\(([\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?(,([\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?)*\\)'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Ob' class='de'><h1>str</h1><div class='re'><code>'&lt;([\\w\\d_-]+((\\#[\\w\\d_-]+|\\.[\\w\\d_-]+)+)?|(\\#[\\w\\d_-]+|\\.[\\w\\d_-]+)+)(\\(([\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?(,([\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?)*\\))?\\:?'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Pb' class='de'><h1>str</h1><div class='re'><code>'(\\#[\\w\\d_-]+|\\.[\\w\\d_-]+)+'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Qb' class='de'><h1>str</h1><div class='re'><code>'[\\w\\d_-]+'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_a' class='de'><h1>Module <span class='n'>engine</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sb' class='de'><h1>Function <span class='n'>getLocalFile</span></h1><div class='re'><code>getLocalFile(  )</code></div><div class='ds'><p>Returns a Railways LocalFile component initialized with the Pamela processor.</p></div></div><div id='d_Tb' class='de'><h1>Function <span class='n'>getProcessors</span></h1><div class='re'><code>getProcessors(  )</code></div><div class='ds'><p>Returns a dictionary with the Railways LocalFiles processors already setup.</p></div></div><div id='d_Ub' class='de'><h1>Function <span class='n'>processPamela</span></h1><div class='re'><code>processPamela( pamelaText, path )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Vb' class='de'><h1>Function <span class='n'>processSugar</span></h1><div class='re'><code>processSugar( sugarText, path )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wb' class='de'><h1>Function <span class='n'>run</span></h1><div class='re'><code>run( arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Rb' class='de'><h1>Module <span class='n'>web</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div>
	<!-- descriptions-snip -->
</div>
<div id='hidden'>
	<!-- hidden-snip -->
	<div id='d_M' class='de'><h1>Method <span class='n'>startIndent</span></h1><div class='re'><code>startIndent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Wb' class='de'><h1>Function <span class='n'>run</span></h1><div class='re'><code>run( arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_eb' class='de'><h1>Class <span class='n'>Writer</span></h1><div class='re'></div><div class='ds'><p>The Writer class implements a simple SAX-like interface to create the resulting HTML/XML document. This is not API-compatible with SAX because Pamela as slightly differnt information than what SAX offers, which requires specific methods.</p></div></div><div id='Rb' class='ro'><div class='n'><a href='javascript:dS("Rb");'>web</a></div><div class='t'>Functions</div class='t'><div class='g'><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Rb","Sb");'>getLocalFile</a></span><br /><span class='d'><span class='prefix'>&lambda;</span><a href='javascript:dO("Rb","Tb");'>getProcessors</a></span><br /><span class='u'><span class='prefix'>&lambda;</span><a href='javascript:dO("Rb","Ub");'>processPamela</a></span><br /><span class='u'><span class='prefix'>&lambda;</span><a href='javascript:dO("Rb","Vb");'>processSugar</a></span><br /><span class='u'><span class='prefix'>&lambda;</span><a href='javascript:dO("Rb","Wb");'>run</a></span><br /></div></div><div id='d_Lb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_ub' class='de'><h1>tuple</h1><div class='re'><code>('i', 'ib', 'sl', 'p', 'n', 's', 'c')</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_Db' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_mb' class='de'><h1>Method <span class='n'>onElementEnd</span></h1><div class='re'><code>onElementEnd( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Z' class='de'><h1>Method <span class='n'>_parsePamelaElement</span></h1><div class='re'><code>_parsePamelaElement( self, element )</code></div><div class='ds'><p>Parses the declaration of a Pamela element, which is like the following examples:</p><pre>html
title:
body#main.body(onclick=load)|c:</pre><p>basically, it is what lies between <code>&lt;</code> and the <code>:</code> (or <code>
</code>), which can be summmed up as:</p><pre>(#ID | NAME #ID?) .CLASS* ATTRIBUTES? |HINTS? :?</pre><p>where attributes is a command-separated sequence of this, surrounded by parens:</p><pre>NAME=(VALUE|'VALUE'|"VALUE")</pre><p>This function returns a triple (name, attributes, hints) representing the parsed element. Attributes are stored as an ordered list of couples <code>(name, value</code>), hints are given as a list of strings.</p></div></div><div id='d_Tb' class='de'><h1>Function <span class='n'>getProcessors</span></h1><div class='re'><code>getProcessors(  )</code></div><div class='ds'><p>Returns a dictionary with the Railways LocalFiles processors already setup.</p></div></div><div id='d_X' class='de'><h1>Method <span class='n'>_parseLine</span></h1><div class='re'><code>_parseLine( self, line )</code></div><div class='ds'><p>Parses the given line of text. This is an internal method that you should not really use directly.</p></div></div><div id='d_Y' class='de'><h1>Method <span class='n'>_parsePamelaAttributes</span></h1><div class='re'><code>_parsePamelaAttributes( self, attributes )</code></div><div class='ds'><p>Parses a string representing Pamela attributes and returns a list of couples <code>[name, value]</code> representing the attributes.</p></div></div><div id='d_R' class='de'><h1>Method <span class='n'>writeText</span></h1><div class='re'><code>writeText( self, text )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_S' class='de'><h1>Class <span class='n'>Parser</span></h1><div class='re'></div><div class='ds'><p>Implements a parser that will turn a Pamela document into an HTML document, returned as a string.</p><p>The main methods that you should use are</p><ul><li><code>parseFile</code> to parse file identified by the given path </li><li><code>parseString</code> to parse a string given as parameter</li></ul><p>You can configure the parser by using the following methods:</p><ul><li><code>acceptTabsOnly</code>, to tell that the parser will only accept tabs. </li><li><code>acceptSpacesOnly</code>, to tell that the parser will only accept spaces. </li><li><code>acceptTabsAndSpaces</code>, to tell that the parser will accept both tabs and spaces. </li><li><code>tabsWidth</code>, to specify the width of a tab in spaces, which is only used when the parser accepts both tabs and spaces. </li></ul></div></div><div id='d_P' class='de'><h1>Method <span class='n'>wrapText</span></h1><div class='re'><code>wrapText( self, text, offset=0, textWidth=80, indent=None )</code></div><div class='ds'><p>Wraps the given text at the given <code>textWidth</code>, starting at the given <code>offset</code> with the given optional <code>ident</code>.</p></div></div><div id='d_Q' class='de'><h1>Method <span class='n'>writeTag</span></h1><div class='re'><code>writeTag( self, tagText )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_V' class='de'><h1>Method <span class='n'>_gotoParentElement</span></h1><div class='re'><code>_gotoParentElement( self, currentIndent )</code></div><div class='ds'><p>Finds the parent element that has an identation lower than the given <code>currentIndent</code>.</p></div></div><div id='d_W' class='de'><h1>Method <span class='n'>_parseContentLine</span></h1><div class='re'><code>_parseContentLine( self, line )</code></div><div class='ds'><p>Parses a line that is data/text that is part of an element content.</p></div></div><div id='d_T' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_U' class='de'><h1>Method <span class='n'>_getLineIndent</span></h1><div class='re'><code>_getLineIndent( self, line )</code></div><div class='ds'><p>Returns the line indentation as a number. It takes into account the fact that tabs may be requried or not, and also takes into account the <code>tabsWith</code> property.</p></div></div><div id='d_J' class='de'><h1>Method <span class='n'>setDefaults</span></h1><div class='re'><code>setDefaults( self, element, formatOptions=() )</code></div><div class='ds'><p>Sets the formatting defaults for the given element name.</p></div></div><div id='d_K' class='de'><h1>Method <span class='n'>setFlag</span></h1><div class='re'><code>setFlag( self, flag )</code></div><div class='ds'><p>Sets the given flag.</p></div></div><div id='d_H' class='de'><h1>Method <span class='n'>pushFlags</span></h1><div class='re'><code>pushFlags( self, *flags )</code></div><div class='ds'><p>Pushes the given flags (as varargs) on the flags queue.</p></div></div><div id='d_I' class='de'><h1>Method <span class='n'>reformatText</span></h1><div class='re'><code>reformatText( self, text )</code></div><div class='ds'><p>Reformats a text so that it fits a particular text width.</p></div></div><div id='d_N' class='de'><h1>Method <span class='n'>startWriting</span></h1><div class='re'><code>startWriting( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_O' class='de'><h1>Method <span class='n'>stripText</span></h1><div class='re'><code>stripText( self, text )</code></div><div class='ds'><p>Strips leading and trailing spaces or eols from this text</p></div></div><div id='d_L' class='de'><h1>Method <span class='n'>setFlags</span></h1><div class='re'><code>setFlags( self, *flags )</code></div><div class='ds'><p>Set the given flags, given as varargs.</p></div></div><div id='d_bb' class='de'><h1>Method <span class='n'>parseText</span></h1><div class='re'><code>parseText( self, text )</code></div><div class='ds'><p>Parses the given string and returns an HTML document.</p></div></div><div id='d_B' class='de'><h1>Method <span class='n'>hasFlag</span></h1><div class='re'><code>hasFlag( self, flag )</code></div><div class='ds'><p>Tells if the given flag is currently defined.</p></div></div><div id='d_C' class='de'><h1>Method <span class='n'>indentAsSpaces</span></h1><div class='re'><code>indentAsSpaces( self, indent=None, increment=0 )</code></div><div class='ds'><p>Converts the <code>indent</code> value to a string filled with spaces or tabs depending on the formatter parameters.</p></div></div><div id='d_A' class='de'><h1>Method <span class='n'>getFlags</span></h1><div class='re'><code>getFlags( self )</code></div><div class='ds'><p>Returns the list of defined flags, by order of definition (last flags are more recent.</p></div></div><div id='d_F' class='de'><h1>Method <span class='n'>normalizeText</span></h1><div class='re'><code>normalizeText( self, text )</code></div><div class='ds'><p>Replaces the tabs and eols by spaces, ignoring the value of tabs.</p></div></div><div id='d_G' class='de'><h1>Method <span class='n'>popFlags</span></h1><div class='re'><code>popFlags( self )</code></div><div class='ds'><p>Pops the given flags from the flags queue.</p></div></div><div id='d_D' class='de'><h1>Method <span class='n'>indentString</span></h1><div class='re'><code>indentString( self, text, indent=None, start=True, end=False )</code></div><div class='ds'><p>Indents the given <code>text</code> with the given <code>value</code> (which will be converted to either spaces or tabs, depending on the formatter parameters.</p><p>If <code>start</code> is True, then the start line will be indented as well, otherwise it won't. When 'end' is True, a newline is inserted at the end of the resulting text, otherwise not.</p></div></div><div id='d_E' class='de'><h1>Method <span class='n'>newLine</span></h1><div class='re'><code>newLine( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_z' class='de'><h1>Method <span class='n'>getDefaults</span></h1><div class='re'><code>getDefaults( self, elementName )</code></div><div class='ds'><p>Gets the formatting defaults for the given element name.</p></div></div><div id='d_x' class='de'><h1>Method <span class='n'>format</span></h1><div class='re'><code>format( self, document, indent=0 )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_y' class='de'><h1>Method <span class='n'>formatText</span></h1><div class='re'><code>formatText( self, text )</code></div><div class='ds'><p>Returns the given text properly formatted according to this formatted configuration.</p></div></div><div id='d_rb' class='de'><h1>str</h1><div class='re'><code>'i'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_r' class='de'><h1>Method <span class='n'>_isNewLine</span></h1><div class='re'><code>_isNewLine( self )</code></div><div class='ds'><p>Tells wether the current line is a new line.</p></div></div><div id='d_s' class='de'><h1>Method <span class='n'>_iterateOnWords</span></h1><div class='re'><code>_iterateOnWords( self, text )</code></div><div class='ds'><p>Splits the given text into words (separated by <code> </code>, <code>	</code> or <code>
</code>) and returns an iterator on these words.</p><p>This function is used by <code>wrapText</code>.</p></div></div><div id='d_p' class='de'><h1>Method <span class='n'>_formatElement</span></h1><div class='re'><code>_formatElement( self, element )</code></div><div class='ds'><p>Formats the given element and its content, by using the formatting operations defined in this class.</p></div></div><div id='d_q' class='de'><h1>Method <span class='n'>_inlineCanSpanOneLine</span></h1><div class='re'><code>_inlineCanSpanOneLine( self, element )</code></div><div class='ds'><p>Tells wether the given element (when considered as an inline) can span one single line. It can if only it has inlines that can span one line and text without EOLs as content.</p></div></div><div id='d_v' class='de'><h1>Method <span class='n'>ensureNewLine</span></h1><div class='re'><code>ensureNewLine( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='l' class='cr'><div class='n'><a href='javascript:dS("l");'>Formatter</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("l","h");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("l","m");'><span class='special __init__'>constructor</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","n");'>_ensureNewLine</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","o");'>_formatContent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","p");'>_formatElement</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","q");'>_inlineCanSpanOneLine</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","r");'>_isNewLine</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","s");'>_iterateOnWords</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","t");'>endIndent</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","u");'>endWriting</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","v");'>ensureNewLine</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","w");'>findFlag</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","x");'>format</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","y");'>formatText</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","z");'>getDefaults</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","A");'>getFlags</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","B");'>hasFlag</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","C");'>indentAsSpaces</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","D");'>indentString</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","E");'>newLine</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","F");'>normalizeText</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","G");'>popFlags</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","H");'>pushFlags</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","I");'>reformatText</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","J");'>setDefaults</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","K");'>setFlag</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","L");'>setFlags</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","M");'>startIndent</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","N");'>startWriting</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","O");'>stripText</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","P");'>wrapText</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","Q");'>writeTag</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("l","R");'>writeText</a></span><br /></div></div><div id='d_t' class='de'><h1>Method <span class='n'>endIndent</span></h1><div class='re'><code>endIndent( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_u' class='de'><h1>Method <span class='n'>endWriting</span></h1><div class='re'><code>endWriting( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_j' class='de'><h1>Method <span class='n'>_attributesAsHTML</span></h1><div class='re'><code>_attributesAsHTML( self )</code></div><div class='ds'><p>Returns the attributes as HTML</p></div></div><div id='d_k' class='de'><h1>Method <span class='n'>append</span></h1><div class='re'><code>append( self, n )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_h' class='de'><h1>tuple</h1><div class='re'><code>()</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_i' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name, attributes=None, isInline=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_n' class='de'><h1>Method <span class='n'>_ensureNewLine</span></h1><div class='re'><code>_ensureNewLine( self )</code></div><div class='ds'><p>Ensures that there is a new line.</p></div></div><div id='d_o' class='de'><h1>Method <span class='n'>_formatContent</span></h1><div class='re'><code>_formatContent( self, element )</code></div><div class='ds'><p>Formats the content of the given element. This uses the formatting operations defined in this class.</p></div></div><div id='d_l' class='de'><h1>Class <span class='n'>Formatter</span></h1><div class='re'></div><div class='ds'><p>Formats the elements of the Pamela object model. A formatter really acts as a state machine, and keeps track of the various formatting hints bound to the Pamela XML/HTML elements to render the document in the most appropriate way.</p><p>If you instanciate a formatter, you'll have access to the following attributes, which can influence the generated text:</p><ul><li><code>indent=0</code> </li><li><code>indentValue="  "</code> </li><li><code>textWidth=80</code> </li><li><code>defaults=HTML_DEFAULT</code></li></ul></div></div><div id='d_m' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><p>Creates a new formatter.</p></div></div><div id='d_w' class='de'><h1>Method <span class='n'>findFlag</span></h1><div class='re'><code>findFlag( self, flag )</code></div><div class='ds'><p>Finds the level at which the given flag is defined. Returns -1 if it is not found.</p></div></div><div id='d_c' class='de'><h1>tuple</h1><div class='re'><code>(&lt;class engine.Element at 0x10b4ed0&gt;,)</code></div><div class='ds'><p>tuple() -&gt; an empty tuple tuple(sequence) -&gt; tuple initialized from sequence's items</p><p>If the argument is a tuple, the return value is the same object.</p></div></div><div id='d_a' class='de'><h1>Module <span class='n'>engine</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_f' class='de'><h1>Method <span class='n'>append</span></h1><div class='re'><code>append( self, n )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_g' class='de'><h1>Class <span class='n'>Element</span></h1><div class='re'></div><div class='ds'><p>Represents an element within the HTML document.</p></div></div><div id='d_d' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, name, attributes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_jb' class='de'><h1>Method <span class='n'>onDeclarationStart</span></h1><div class='re'><code>onDeclarationStart( self, name, attributes=None )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ob' class='de'><h1>Method <span class='n'>onTextAdd</span></h1><div class='re'><code>onTextAdd( self, text )</code></div><div class='ds'><p>Adds the given text fragment to the current element.</p></div></div><div id='eb' class='cr'><div class='n'><a href='javascript:dS("eb");'>Writer</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("eb","h");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("eb","fb");'><span class='special __init__'>constructor</span></a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("eb","gb");'>_node</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("eb","hb");'>onComment</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("eb","ib");'>onDeclarationEnd</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("eb","jb");'>onDeclarationStart</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("eb","kb");'>onDocumentEnd</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("eb","lb");'>onDocumentStart</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("eb","mb");'>onElementEnd</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("eb","nb");'>onElementStart</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("eb","ob");'>onTextAdd</a></span><br /></div></div><div id='d_Ib' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_gb' class='de'><h1>Method <span class='n'>_node</span></h1><div class='re'><code>_node( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Nb' class='de'><h1>str</h1><div class='re'><code>'\\(([\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?(,([\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?)*\\)'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_wb' class='de'><h1>str</h1><div class='re'><code>'sl'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Eb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Fb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_Qb' class='de'><h1>str</h1><div class='re'><code>'[\\w\\d_-]+'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Vb' class='de'><h1>Function <span class='n'>processSugar</span></h1><div class='re'><code>processSugar( sugarText, path )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_db' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self, content )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='S' class='cr'><div class='n'><a href='javascript:dS("S");'>Parser</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("S","h");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("S","T");'><span class='special __init__'>constructor</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("S","U");'>_getLineIndent</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("S","V");'>_gotoParentElement</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("S","W");'>_parseContentLine</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("S","X");'>_parseLine</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("S","Y");'>_parsePamelaAttributes</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("S","Z");'>_parsePamelaElement</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("S","ab");'>parseFile</a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("S","bb");'>parseText</a></span><br /></div></div><div id='d_tb' class='de'><h1>str</h1><div class='re'><code>'n'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Ob' class='de'><h1>str</h1><div class='re'><code>'&lt;([\\w\\d_-]+((\\#[\\w\\d_-]+|\\.[\\w\\d_-]+)+)?|(\\#[\\w\\d_-]+|\\.[\\w\\d_-]+)+)(\\(([\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?(,([\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?)*\\))?\\:?'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='g' class='cr'><div class='n'><a href='javascript:dS("g");'>Element</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("g","h");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("g","i");'><span class='special __init__'>constructor</span></a></span><br /><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("g","j");'>_attributesAsHTML</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("g","k");'>append</a></span><br /></div></div><div id='d_lb' class='de'><h1>Method <span class='n'>onDocumentStart</span></h1><div class='re'><code>onDocumentStart( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_e' class='de'><h1>Method <span class='n'>_attributesAsHTML</span></h1><div class='re'><code>_attributesAsHTML( self )</code></div><div class='ds'><p>Returns the attributes as HTML</p></div></div><div id='d_Gb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_xb' class='de'><h1>str</h1><div class='re'><code>'s'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='cb' class='cr'><div class='n'><a href='javascript:dS("cb");'>Text</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("cb","h");'><span class='special __bases__'><i>Base class</i></span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("cb","db");'><span class='special __init__'>constructor</span></a></span><br /></div></div><div id='d_ab' class='de'><h1>Method <span class='n'>parseFile</span></h1><div class='re'><code>parseFile( self, path )</code></div><div class='ds'><p>Parses the file with the given path, and return the corresponding HTML document.</p></div></div><div id='d_Kb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_pb' class='de'><h1>Function <span class='n'>run</span></h1><div class='re'><code>run( arguments )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_ib' class='de'><h1>Method <span class='n'>onDeclarationEnd</span></h1><div class='re'><code>onDeclarationEnd( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Sb' class='de'><h1>Function <span class='n'>getLocalFile</span></h1><div class='re'><code>getLocalFile(  )</code></div><div class='ds'><p>Returns a Railways LocalFile component initialized with the Pamela processor.</p></div></div><div id='d_nb' class='de'><h1>Method <span class='n'>onElementStart</span></h1><div class='re'><code>onElementStart( self, name, attributes=None, isInline=False )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_yb' class='de'><h1>str</h1><div class='re'><code>'w'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Hb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_fb' class='de'><h1>Method <span class='n'>__init__</span></h1><div class='re'><code>__init__( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_qb' class='de'><h1>str</h1><div class='re'><code>'c'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='b' class='cr'><div class='n'><a href='javascript:dS("b");'>Declaration</a></div><div class='t'>Bases</div class='t'><div class='g'><span class='d'><span class='prefix'>&equiv;</span><a href='javascript:dO("b","c");'><span class='special __bases__'>Element</span></a></span><br /></div><div class='t'>Methods</div class='t'><div class='g'><span class='u'><span class='prefix'>&equiv;</span><a href='javascript:dO("b","d");'><span class='special __init__'>constructor</span></a></span><br /></div><div class='t'>Inhertied Methods</div class='t'><div class='g'><span class='d'><span class='prefix'>&fnof;</span><a href='javascript:dO("b","e");'>_attributesAsHTML</a></span><br /><span class='u'><span class='prefix'>&fnof;</span><a href='javascript:dO("b","f");'>append</a></span><br /></div></div><div id='d_vb' class='de'><h1>str</h1><div class='re'><code>'p'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Ab' class='de'><h1>dict</h1><div class='re'><code>{'div': {'NOT_EMPTY': '&znjs;'}, 'script': {'NOT_EMPTY': ' '}}</code></div><div class='ds'><p>dict() -&gt; new empty dictionary. dict(mapping) -&gt; new dictionary initialized from a mapping object's (key, value) pairs. dict(seq) -&gt; new dictionary initialized as if via: d = {} for k, v in seq: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)</p></div></div><div id='d_Pb' class='de'><h1>str</h1><div class='re'><code>'(\\#[\\w\\d_-]+|\\.[\\w\\d_-]+)+'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Ub' class='de'><h1>Function <span class='n'>processPamela</span></h1><div class='re'><code>processPamela( pamelaText, path )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_cb' class='de'><h1>Class <span class='n'>Text</span></h1><div class='re'></div><div class='ds'><p>Reprensents a text fragment within the HTML document.</p></div></div><div id='d_zb' class='de'><h1>dict</h1><div class='re'><code>{'pre': ['p'], 'code': ['n', 's', 'c'], 'p': ['n', 's', 'c', 'w'], 'title': ['sl', 'n', 's'], 'h2': ['sl', 'n', 's'], 'h3': ['sl', 'n', 's'], 'h1': ['sl', 'n', 's'], 'h4': ['sl', 'n', 's'], 'script': ['i'], 'link': ['i'], 'div': ['ib']}</code></div><div class='ds'><p>dict() -&gt; new empty dictionary. dict(mapping) -&gt; new dictionary initialized from a mapping object's (key, value) pairs. dict(seq) -&gt; new dictionary initialized as if via: d = {} for k, v in seq: d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs in the keyword argument list. For example: dict(one=1, two=2)</p></div></div><div id='d_b' class='de'><h1>Class <span class='n'>Declaration</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Mb' class='de'><h1>str</h1><div class='re'><code>'([\\w\\d_-]+)(=(\'[^\']+\'|"[^"]+"|([^),]+)))?'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_kb' class='de'><h1>Method <span class='n'>onDocumentEnd</span></h1><div class='re'><code>onDocumentEnd( self )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_Bb' class='de'><h1>str</h1><div class='re'><code>'0.3.4'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Rb' class='de'><h1>Module <span class='n'>web</span></h1><div class='re'></div><div class='ds'><span class='u'>Undocumented</span></div></div><div id='d_sb' class='de'><h1>str</h1><div class='re'><code>'ib'</code></div><div class='ds'><p>str(object) -&gt; string</p><p>Return a nice string representation of the object. If the argument is a string, the return value is the same object.</p></div></div><div id='d_Jb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='a' class='ro'><div class='n'><a href='javascript:dS("a");'>engine</a></div><div class='t'>Classes</div class='t'><div class='g'><span class='u'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","b");'>Declaration</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","g");'>Element</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","l");'>Formatter</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","S");'>Parser</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","cb");'>Text</a></span><br /><span class='d'><span class='prefix'>&Tau;</span><a href='javascript:dO("a","eb");'>Writer</a></span><br /></div><div class='t'>Functions</div class='t'><div class='g'><span class='u'><span class='prefix'>&lambda;</span><a href='javascript:dO("a","pb");'>run</a></span><br /></div><div class='t'>Values</div class='t'><div class='g'><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","qb");'>FORMAT_COMPACT</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","rb");'>FORMAT_INLINE</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","sb");'>FORMAT_INLINE_BLOCK</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","tb");'>FORMAT_NORMALIZE</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","ub");'>FORMAT_OPTIONS</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","vb");'>FORMAT_PRESERVE</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","wb");'>FORMAT_SINGLE_LINE</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","xb");'>FORMAT_STRIP</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","yb");'>FORMAT_WRAP</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","zb");'>HTML_DEFAULTS</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Ab");'>HTML_EXCEPTIONS</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Bb");'>PAMELA_VERSION</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Cb");'>RE_ATTRIBUTE</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Db");'>RE_COMMENT</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Eb");'>RE_DECLARATION</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Fb");'>RE_ELEMENT</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Gb");'>RE_EMPTY</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Hb");'>RE_INLINE</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Ib");'>RE_LEADING_SPC</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Jb");'>RE_LEADING_TAB</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Kb");'>RE_SPACE</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Lb");'>RE_SPACES</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Mb");'>SYMBOL_ATTR</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Nb");'>SYMBOL_ATTRS</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Ob");'>SYMBOL_ELEMENT</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Pb");'>SYMBOL_ID_CLS</a></span><br /><span class='d'><span class='prefix'>&bull;</span><a href='javascript:dO("a","Qb");'>SYMBOL_NAME</a></span><br /></div></div><div id='d_Cb' class='de'><h1>SRE_Pattern</h1><div class='re'></div><div class='ds'><p>Compiled regular expression objects</p></div></div><div id='d_hb' class='de'><h1>Method <span class='n'>onComment</span></h1><div class='re'><code>onComment( self, line )</code></div><div class='ds'><span class='u'>Undocumented</span></div></div>
	<!-- hidden-snip -->
	<!-- hidden nodes will be moved here -->
</div>
</div>
<!-- body -->
</body>
</html>
